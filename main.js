/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LLMBridgesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var http = __toESM(require("http"), 1);

// src/kb-manager.ts
var import_obsidian = require("obsidian");

// src/types.ts
var VALIDATION_INSTRUCTIONS = {
  create_note: `Please verify the note against the knowledge base's organization_rules:

1. Check that the note content follows the organization guidelines
2. Ensure the note structure matches KB conventions
3. Verify all recommended metadata is present

If any issues are found, call update_note with corrected content.`,
  update_note: `Please verify the update against the knowledge base's organization_rules:

1. Compare original and updated content to ensure no important information was lost
2. Check that the updated note follows the organization guidelines
3. Verify the note structure matches KB conventions
4. Ensure all links and references are intact

If any issues are found, call update_note again with corrected content.`,
  append_note: `Please verify the append operation against the knowledge base's organization_rules:

1. Check that the combined content makes logical sense
2. Verify the appended content integrates well with existing content
3. Ensure no duplicate information was introduced
4. Check that overall note structure remains compliant

If any issues are found, call update_note with corrected content.`,
  move_note: `Please verify the moved note against the knowledge base's organization_rules:

1. Check that the note content still follows organization guidelines for its new location
2. Verify any path-dependent content (links, references) is still valid

If any issues are found, call update_note with corrected content.`
};
var LLM_BRIDGES_DIR = ".llm_bridges";
var KNOWLEDGE_BASE_DIR = "knowledge_base";
var FOLDER_CONSTRAINTS_DIR = "folder_constraints";
var META_FILE = "meta.md";
var DEFAULT_READ_LIMIT = 1e4;

// src/kb-manager.ts
var KBManager = class {
  constructor(app) {
    this.app = app;
  }
  // ============================================================================
  // Path Helpers
  // ============================================================================
  /**
   * Get the base path for all KB storage
   */
  getKBBasePath() {
    return `${LLM_BRIDGES_DIR}/${KNOWLEDGE_BASE_DIR}`;
  }
  /**
   * Get the path for a specific KB's directory
   */
  getKBPath(kbName) {
    return `${this.getKBBasePath()}/${kbName}`;
  }
  /**
   * Get the path for a KB's meta.md file
   */
  getMetaPath(kbName) {
    return `${this.getKBPath(kbName)}/${META_FILE}`;
  }
  /**
   * Get the path for a KB's folder_constraints directory
   */
  getConstraintsPath(kbName) {
    return `${this.getKBPath(kbName)}/${FOLDER_CONSTRAINTS_DIR}`;
  }
  // ============================================================================
  // Knowledge Base Operations
  // ============================================================================
  /**
   * List all Knowledge Bases
   */
  async listKnowledgeBases() {
    const basePath = this.getKBBasePath();
    const baseFolder = this.app.vault.getAbstractFileByPath(basePath);
    if (!(baseFolder instanceof import_obsidian.TFolder)) {
      return [];
    }
    const kbs = [];
    for (const child of baseFolder.children) {
      if (child instanceof import_obsidian.TFolder) {
        try {
          const kb = await this.getKnowledgeBase(child.name);
          if (kb) {
            kbs.push({
              name: kb.name,
              description: kb.description,
              subfolder: kb.subfolder,
              create_time: kb.create_time,
              organization_rules_preview: kb.organization_rules.slice(0, 200) + (kb.organization_rules.length > 200 ? "..." : "")
            });
          }
        } catch (e) {
        }
      }
    }
    return kbs;
  }
  /**
   * Get a single Knowledge Base by name
   */
  async getKnowledgeBase(name) {
    const metaPath = this.getMetaPath(name);
    const file = this.app.vault.getAbstractFileByPath(metaPath);
    if (!(file instanceof import_obsidian.TFile)) {
      return null;
    }
    const content = await this.app.vault.read(file);
    return this.parseKBMeta(name, content);
  }
  /**
   * Add a new Knowledge Base
   */
  async addKnowledgeBase(name, description, subfolder, organizationRules) {
    const existing = await this.getKnowledgeBase(name);
    if (existing) {
      throw this.createError("knowledge_base_already_exists", `Knowledge base '${name}' already exists`);
    }
    const allKBs = await this.listKnowledgeBases();
    for (const kb2 of allKBs) {
      if (this.subfolderOverlaps(subfolder, kb2.subfolder)) {
        throw this.createError(
          "subfolder_overlap",
          `Subfolder '${subfolder}' overlaps with KB '${kb2.name}' subfolder '${kb2.subfolder}'`
        );
      }
    }
    const kbPath = this.getKBPath(name);
    const constraintsPath = this.getConstraintsPath(name);
    await this.ensureFolder(kbPath);
    await this.ensureFolder(constraintsPath);
    const kb = {
      name,
      create_time: new Date().toISOString(),
      description,
      subfolder: this.normalizePath(subfolder),
      organization_rules: organizationRules
    };
    const metaContent = this.serializeKBMeta(kb);
    await this.app.vault.create(this.getMetaPath(name), metaContent);
    await this.ensureFolder(kb.subfolder);
    return kb;
  }
  /**
   * Update an existing Knowledge Base
   */
  async updateKnowledgeBase(name, updates) {
    var _a, _b;
    const kb = await this.getKnowledgeBase(name);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${name}' not found`);
    }
    if (updates.subfolder && updates.subfolder !== kb.subfolder) {
      const allKBs = await this.listKnowledgeBases();
      for (const otherKb of allKBs) {
        if (otherKb.name !== name && this.subfolderOverlaps(updates.subfolder, otherKb.subfolder)) {
          throw this.createError(
            "subfolder_overlap",
            `Subfolder '${updates.subfolder}' overlaps with KB '${otherKb.name}' subfolder '${otherKb.subfolder}'`
          );
        }
      }
    }
    const updatedKB = {
      ...kb,
      description: (_a = updates.description) != null ? _a : kb.description,
      subfolder: updates.subfolder ? this.normalizePath(updates.subfolder) : kb.subfolder,
      organization_rules: (_b = updates.organization_rules) != null ? _b : kb.organization_rules
    };
    const metaPath = this.getMetaPath(name);
    const file = this.app.vault.getAbstractFileByPath(metaPath);
    if (file instanceof import_obsidian.TFile) {
      await this.app.vault.modify(file, this.serializeKBMeta(updatedKB));
    }
    if (updates.subfolder) {
      await this.ensureFolder(updatedKB.subfolder);
    }
    return updatedKB;
  }
  // ============================================================================
  // Folder Constraint Operations
  // ============================================================================
  /**
   * Get all folder constraints for a KB
   */
  async getFolderConstraints(kbName) {
    const kb = await this.getKnowledgeBase(kbName);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${kbName}' not found`);
    }
    const constraintsPath = this.getConstraintsPath(kbName);
    const folder = this.app.vault.getAbstractFileByPath(constraintsPath);
    if (!(folder instanceof import_obsidian.TFolder)) {
      return [];
    }
    const constraints = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile && child.extension === "md") {
        try {
          const content = await this.app.vault.read(child);
          const constraint = this.parseConstraint(kbName, content);
          if (constraint) {
            constraints.push(constraint);
          }
        } catch (e) {
        }
      }
    }
    return constraints;
  }
  /**
   * Add a folder constraint to a KB
   */
  async addFolderConstraint(kbName, subfolder, rules) {
    const kb = await this.getKnowledgeBase(kbName);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${kbName}' not found`);
    }
    const normalizedSubfolder = this.normalizePath(subfolder);
    if (!normalizedSubfolder.startsWith(kb.subfolder)) {
      throw this.createError(
        "invalid_note_path",
        `Subfolder '${subfolder}' is outside KB's scope '${kb.subfolder}'`
      );
    }
    const constraint = {
      kb_name: kbName,
      subfolder: normalizedSubfolder,
      rules
    };
    const constraintsPath = this.getConstraintsPath(kbName);
    await this.ensureFolder(constraintsPath);
    const filename = this.sanitizeFilename(normalizedSubfolder) + ".md";
    const filePath = `${constraintsPath}/${filename}`;
    const content = this.serializeConstraint(constraint);
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(filePath, content);
    }
    return constraint;
  }
  // ============================================================================
  // Note Path Validation
  // ============================================================================
  /**
   * Resolve and validate a note path within a KB's scope
   */
  resolveNotePath(kb, notePath) {
    let resolved = notePath;
    if (!resolved.startsWith(kb.subfolder + "/") && resolved !== kb.subfolder) {
      resolved = `${kb.subfolder}/${notePath}`;
    }
    resolved = this.normalizePath(resolved);
    if (!resolved.startsWith(kb.subfolder + "/") && resolved !== kb.subfolder) {
      throw this.createError("invalid_note_path", `Path '${notePath}' is outside KB scope '${kb.subfolder}'`);
    }
    if (resolved.includes("..")) {
      throw this.createError("invalid_note_path", "Path traversal not allowed");
    }
    return resolved;
  }
  /**
   * Check if a note exists
   */
  noteExists(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    return file instanceof import_obsidian.TFile;
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  /**
   * Parse KB meta.md content into KnowledgeBase object
   */
  parseKBMeta(name, content) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      throw new Error("Invalid meta.md format");
    }
    const frontmatter = this.parseSimpleYaml(match[1]);
    const organizationRules = match[2].trim();
    return {
      name,
      create_time: String(frontmatter.create_time || new Date().toISOString()),
      description: String(frontmatter.description || ""),
      subfolder: String(frontmatter.subfolder || ""),
      organization_rules: organizationRules
    };
  }
  /**
   * Serialize KnowledgeBase to meta.md content
   */
  serializeKBMeta(kb) {
    return `---
create_time: "${kb.create_time}"
description: "${kb.description.replace(/"/g, '\\"')}"
subfolder: "${kb.subfolder}"
---

${kb.organization_rules}`;
  }
  /**
   * Parse constraint file content
   */
  parseConstraint(kbName, content) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return null;
    }
    const frontmatter = this.parseSimpleYaml(match[1]);
    const body = match[2];
    const rulesMatch = body.match(/```ya?ml\r?\n([\s\S]*?)\r?\n```/);
    let rules = {};
    if (rulesMatch) {
      try {
        rules = this.parseRulesYaml(rulesMatch[1]);
      } catch (e) {
      }
    }
    return {
      kb_name: kbName,
      subfolder: String(frontmatter.subfolder || ""),
      rules
    };
  }
  /**
   * Serialize constraint to markdown
   */
  serializeConstraint(constraint) {
    const rulesYaml = this.serializeRulesYaml(constraint.rules);
    return `---
subfolder: "${constraint.subfolder}"
---

## Rules

\`\`\`yaml
${rulesYaml}
\`\`\`
`;
  }
  /**
   * Simple YAML parser
   */
  parseSimpleYaml(yaml) {
    const result = {};
    const lines = yaml.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      const colonIndex = trimmed.indexOf(":");
      if (colonIndex > 0) {
        const key = trimmed.slice(0, colonIndex).trim();
        let value = trimmed.slice(colonIndex + 1).trim();
        if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        result[key] = value;
      }
    }
    return result;
  }
  /**
   * Parse rules YAML - handles nested structure
   */
  parseRulesYaml(yaml) {
    const rules = {};
    const lines = yaml.split("\n");
    let currentSection = null;
    let currentField = null;
    const fields = [];
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      if (!line.startsWith(" ") && !line.startsWith("	")) {
        if (currentSection === "frontmatter" && fields.length > 0) {
          rules.frontmatter = { required_fields: fields.slice() };
        }
        const colonIdx = trimmed.indexOf(":");
        if (colonIdx > 0) {
          currentSection = trimmed.slice(0, colonIdx).trim();
          const value = trimmed.slice(colonIdx + 1).trim();
          if (currentSection === "filename" && value) {
          }
        }
        currentField = null;
        fields.length = 0;
        continue;
      }
      if (currentSection === "frontmatter") {
        if (trimmed.startsWith("- name:")) {
          if (currentField) {
            fields.push(currentField);
          }
          currentField = { name: trimmed.slice(8).trim(), type: "string" };
        } else if (currentField && trimmed.includes(":")) {
          const [key, ...valueParts] = trimmed.split(":");
          const keyName = key.trim();
          let value = valueParts.join(":").trim();
          if (value === "true")
            value = true;
          else if (value === "false")
            value = false;
          else if (value.startsWith("[") && value.endsWith("]")) {
            const arrayStr = value.slice(1, -1);
            value = arrayStr.split(",").map((v) => {
              const trimmedV = v.trim().replace(/^["']|["']$/g, "");
              if (trimmedV === "true")
                return true;
              if (trimmedV === "false")
                return false;
              const num = Number(trimmedV);
              if (!isNaN(num))
                return num;
              return trimmedV;
            });
          } else if (value.startsWith('"') || value.startsWith("'")) {
            value = value.slice(1, -1);
          }
          if (keyName === "type") {
            currentField.type = value;
          } else if (keyName === "pattern") {
            currentField.pattern = value;
          } else if (keyName === "allowed_values") {
            currentField.allowed_values = value;
          }
        }
      } else if (currentSection === "filename") {
        if (trimmed.startsWith("pattern:")) {
          const pattern = trimmed.slice(8).trim().replace(/^["']|["']$/g, "");
          rules.filename = { pattern };
        }
      } else if (currentSection === "content") {
        if (!rules.content)
          rules.content = {};
        const colonIdx = trimmed.indexOf(":");
        if (colonIdx > 0) {
          const key = trimmed.slice(0, colonIdx).trim();
          const value = trimmed.slice(colonIdx + 1).trim();
          if (key === "min_length" || key === "max_length") {
            rules.content[key] = parseInt(value) || 0;
          } else if (key === "required_sections") {
            const arr = value.slice(1, -1).split(",").map((v) => v.trim().replace(/^["']|["']$/g, ""));
            rules.content[key] = arr;
          }
        }
      }
    }
    if (currentSection === "frontmatter") {
      if (currentField) {
        fields.push(currentField);
      }
      if (fields.length > 0) {
        rules.frontmatter = { required_fields: fields };
      }
    }
    return rules;
  }
  /**
   * Serialize rules to YAML
   */
  serializeRulesYaml(rules) {
    var _a, _b;
    const lines = [];
    if ((_a = rules.frontmatter) == null ? void 0 : _a.required_fields) {
      lines.push("frontmatter:");
      lines.push("  required_fields:");
      for (const field of rules.frontmatter.required_fields) {
        lines.push(`    - name: ${field.name}`);
        lines.push(`      type: ${field.type}`);
        if (field.pattern) {
          lines.push(`      pattern: "${field.pattern}"`);
        }
        if (field.allowed_values) {
          const values = field.allowed_values.map(
            (v) => typeof v === "string" ? `"${v}"` : String(v)
          ).join(", ");
          lines.push(`      allowed_values: [${values}]`);
        }
      }
    }
    if ((_b = rules.filename) == null ? void 0 : _b.pattern) {
      lines.push("filename:");
      lines.push(`  pattern: "${rules.filename.pattern}"`);
    }
    if (rules.content) {
      lines.push("content:");
      if (rules.content.min_length !== void 0) {
        lines.push(`  min_length: ${rules.content.min_length}`);
      }
      if (rules.content.max_length !== void 0) {
        lines.push(`  max_length: ${rules.content.max_length}`);
      }
      if (rules.content.required_sections) {
        const sections = rules.content.required_sections.map((s) => `"${s}"`).join(", ");
        lines.push(`  required_sections: [${sections}]`);
      }
    }
    return lines.join("\n");
  }
  // ============================================================================
  // Utility Methods
  // ============================================================================
  /**
   * Ensure a folder exists, creating it if necessary
   */
  async ensureFolder(path) {
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing)
      return;
    const parts = path.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const folder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  /**
   * Normalize a path (remove leading/trailing slashes, etc.)
   */
  normalizePath(path) {
    return path.replace(/^\/+|\/+$/g, "").replace(/\/+/g, "/");
  }
  /**
   * Check if two subfolders overlap
   */
  subfolderOverlaps(a, b) {
    const normA = this.normalizePath(a);
    const normB = this.normalizePath(b);
    return normA.startsWith(normB + "/") || normB.startsWith(normA + "/") || normA === normB;
  }
  /**
   * Create a safe filename from a path
   */
  sanitizeFilename(path) {
    return path.replace(/\//g, "_").replace(/[^a-zA-Z0-9_-]/g, "");
  }
  /**
   * Create an API error
   */
  createError(code, message, details) {
    return { code, message, details };
  }
};

// src/validation.ts
function parseNote(content) {
  const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
  const match = content.match(frontmatterRegex);
  if (!match) {
    return {
      frontmatter: {},
      body: content,
      raw: content
    };
  }
  const frontmatterYaml = match[1];
  const body = match[2] || "";
  const frontmatter = parseSimpleYaml(frontmatterYaml);
  return {
    frontmatter,
    body,
    raw: content
  };
}
function parseSimpleYaml(yaml) {
  const result = {};
  const lines = yaml.split("\n");
  let currentKey = null;
  let currentArray = null;
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#"))
      continue;
    if (trimmed.startsWith("- ") && currentKey && currentArray) {
      const value = trimmed.slice(2).trim();
      currentArray.push(parseYamlValue(value));
      continue;
    }
    const colonIndex = trimmed.indexOf(":");
    if (colonIndex > 0) {
      const key = trimmed.slice(0, colonIndex).trim();
      const value = trimmed.slice(colonIndex + 1).trim();
      if (currentKey && currentArray) {
        result[currentKey] = currentArray;
        currentArray = null;
      }
      if (value === "" || value === "[]") {
        currentKey = key;
        currentArray = [];
      } else if (value.startsWith("[") && value.endsWith("]")) {
        const arrayContent = value.slice(1, -1);
        result[key] = arrayContent.split(",").map((v) => parseYamlValue(v.trim())).filter((v) => v !== "");
        currentKey = null;
        currentArray = null;
      } else {
        result[key] = parseYamlValue(value);
        currentKey = null;
        currentArray = null;
      }
    }
  }
  if (currentKey && currentArray) {
    result[currentKey] = currentArray;
  }
  return result;
}
function parseYamlValue(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  if (value === "null" || value === "~")
    return null;
  const num = Number(value);
  if (!isNaN(num) && value !== "")
    return num;
  return value;
}
function validateNote(notePath, content, constraint) {
  var _a, _b;
  const issues = [];
  const parsed = parseNote(content);
  const filename = notePath.split("/").pop() || "";
  if ((_a = constraint.rules.frontmatter) == null ? void 0 : _a.required_fields) {
    for (const field of constraint.rules.frontmatter.required_fields) {
      const fieldIssues = validateFrontmatterField(parsed.frontmatter, field);
      issues.push(...fieldIssues);
    }
  }
  if ((_b = constraint.rules.filename) == null ? void 0 : _b.pattern) {
    const filenameIssues = validateFilename(filename, constraint.rules.filename.pattern);
    issues.push(...filenameIssues);
  }
  if (constraint.rules.content) {
    const contentIssues = validateContent(parsed.body, constraint.rules.content);
    issues.push(...contentIssues);
  }
  return {
    passed: issues.length === 0,
    issues
  };
}
function validateFrontmatterField(frontmatter, field) {
  const issues = [];
  const value = frontmatter[field.name];
  const fieldPath = `frontmatter.${field.name}`;
  if (value === void 0 || value === null) {
    issues.push({
      field: fieldPath,
      error: "missing_required_field",
      message: `Required field '${field.name}' is missing`
    });
    return issues;
  }
  const typeValid = validateFieldType(value, field.type);
  if (!typeValid) {
    issues.push({
      field: fieldPath,
      error: "invalid_field_type",
      expected: field.type,
      actual: typeof value,
      message: `Field '${field.name}' should be type '${field.type}', got '${typeof value}'`
    });
    return issues;
  }
  if (field.pattern && typeof value === "string") {
    try {
      const regex = new RegExp(field.pattern);
      if (!regex.test(value)) {
        issues.push({
          field: fieldPath,
          error: "pattern_mismatch",
          pattern: field.pattern,
          actual: value,
          message: `Field '${field.name}' does not match pattern '${field.pattern}'`
        });
      }
    } catch (e) {
    }
  }
  if (field.allowed_values && field.allowed_values.length > 0) {
    if (!field.allowed_values.includes(value)) {
      issues.push({
        field: fieldPath,
        error: "invalid_value",
        expected: field.allowed_values,
        actual: value,
        message: `Field '${field.name}' must be one of: ${field.allowed_values.join(", ")}`
      });
    }
  }
  return issues;
}
function validateFieldType(value, expectedType) {
  switch (expectedType) {
    case "string":
      return typeof value === "string";
    case "number":
      return typeof value === "number";
    case "boolean":
      return typeof value === "boolean";
    case "date":
      if (typeof value === "string") {
        return /^\d{4}-\d{2}-\d{2}/.test(value);
      }
      return value instanceof Date;
    case "array":
      return Array.isArray(value);
    default:
      return true;
  }
}
function validateFilename(filename, pattern) {
  const issues = [];
  try {
    const regex = new RegExp(pattern);
    if (!regex.test(filename)) {
      issues.push({
        field: "filename",
        error: "pattern_mismatch",
        pattern,
        actual: filename,
        message: `Filename '${filename}' does not match pattern '${pattern}'`
      });
    }
  } catch (e) {
  }
  return issues;
}
function validateContent(body, rules) {
  const issues = [];
  if (!rules)
    return issues;
  if (rules.min_length !== void 0 && body.length < rules.min_length) {
    issues.push({
      field: "content",
      error: "content_too_short",
      expected: rules.min_length,
      actual: body.length,
      message: `Content must be at least ${rules.min_length} characters, got ${body.length}`
    });
  }
  if (rules.max_length !== void 0 && body.length > rules.max_length) {
    issues.push({
      field: "content",
      error: "content_too_long",
      expected: rules.max_length,
      actual: body.length,
      message: `Content must be at most ${rules.max_length} characters, got ${body.length}`
    });
  }
  if (rules.required_sections) {
    for (const section of rules.required_sections) {
      const headingRegex = new RegExp(`^#+\\s+${escapeRegex(section)}\\s*$`, "im");
      if (!headingRegex.test(body)) {
        issues.push({
          field: "content.sections",
          error: "missing_section",
          expected: section,
          message: `Required section '${section}' is missing`
        });
      }
    }
  }
  return issues;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function findApplicableConstraint(notePath, constraints) {
  let bestMatch = null;
  let bestMatchLength = -1;
  for (const constraint of constraints) {
    const constraintPath = constraint.subfolder.replace(/\/$/, "");
    const noteDir = notePath.substring(0, notePath.lastIndexOf("/"));
    if (notePath.startsWith(constraintPath + "/") || noteDir === constraintPath) {
      if (constraintPath.length > bestMatchLength) {
        bestMatch = constraint;
        bestMatchLength = constraintPath.length;
      }
    }
  }
  return bestMatch;
}
function validateConstraintRulesSchema(rules) {
  const issues = [];
  if (!rules || typeof rules !== "object") {
    issues.push({
      field: "rules",
      error: "invalid_field_type",
      expected: "object",
      actual: typeof rules,
      message: "Rules must be an object"
    });
    return { passed: false, issues };
  }
  const rulesObj = rules;
  if (rulesObj.frontmatter !== void 0) {
    if (typeof rulesObj.frontmatter !== "object") {
      issues.push({
        field: "rules.frontmatter",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.frontmatter
      });
    } else {
      const fm = rulesObj.frontmatter;
      if (fm.required_fields !== void 0 && !Array.isArray(fm.required_fields)) {
        issues.push({
          field: "rules.frontmatter.required_fields",
          error: "invalid_field_type",
          expected: "array",
          actual: typeof fm.required_fields
        });
      }
    }
  }
  if (rulesObj.filename !== void 0) {
    if (typeof rulesObj.filename !== "object") {
      issues.push({
        field: "rules.filename",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.filename
      });
    } else {
      const fn = rulesObj.filename;
      if (fn.pattern !== void 0 && typeof fn.pattern !== "string") {
        issues.push({
          field: "rules.filename.pattern",
          error: "invalid_field_type",
          expected: "string",
          actual: typeof fn.pattern
        });
      }
      if (typeof fn.pattern === "string") {
        try {
          new RegExp(fn.pattern);
        } catch (e) {
          issues.push({
            field: "rules.filename.pattern",
            error: "invalid_value",
            actual: fn.pattern,
            message: "Invalid regex pattern"
          });
        }
      }
    }
  }
  if (rulesObj.content !== void 0) {
    if (typeof rulesObj.content !== "object") {
      issues.push({
        field: "rules.content",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.content
      });
    }
  }
  return {
    passed: issues.length === 0,
    issues
  };
}

// src/main.ts
var DEFAULT_SETTINGS = {
  port: 27124,
  apiKey: ""
};
var LLMBridgesPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.server = null;
  }
  async onload() {
    await this.loadSettings();
    this.kbManager = new KBManager(this.app);
    if (!this.settings.apiKey) {
      this.settings.apiKey = this.generateApiKey();
      await this.saveSettings();
    }
    this.addSettingTab(new LLMBridgesSettingTab(this.app, this));
    this.addRibbonIcon("bot", "LLM Bridges", () => {
      new import_obsidian2.Notice(
        this.server ? `LLM Bridges running on port ${this.settings.port}` : "LLM Bridges server not running"
      );
    });
    this.addCommand({
      id: "copy-mcp-config",
      name: "Copy Claude MCP Configuration",
      callback: () => this.copyMCPConfig()
    });
    this.addCommand({
      id: "restart-server",
      name: "Restart Server",
      callback: () => this.restartServer()
    });
    this.startServer();
  }
  onunload() {
    this.stopServer();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  generateApiKey() {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for (let i = 0; i < 32; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  startServer() {
    if (this.server) {
      this.server.close();
    }
    this.server = http.createServer(async (req, res) => {
      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
      res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
      if (req.method === "OPTIONS") {
        res.writeHead(200);
        res.end();
        return;
      }
      const authHeader = req.headers.authorization;
      if (authHeader !== `Bearer ${this.settings.apiKey}`) {
        res.writeHead(401, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Unauthorized" }));
        return;
      }
      try {
        await this.handleRequest(req, res);
      } catch (error) {
        console.error("LLM Bridges error:", error);
        if (this.isApiError(error)) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error }));
          return;
        }
        res.writeHead(500, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: String(error) }));
      }
    });
    this.server.listen(this.settings.port, "127.0.0.1", () => {
      console.log(`LLM Bridges listening on http://127.0.0.1:${this.settings.port}`);
    });
    this.server.on("error", (err) => {
      console.error("LLM Bridges server error:", err);
      new import_obsidian2.Notice(`LLM Bridges: Server error - ${err.message}`);
    });
  }
  stopServer() {
    if (this.server) {
      this.server.close();
      this.server = null;
    }
  }
  restartServer() {
    this.stopServer();
    this.startServer();
    new import_obsidian2.Notice(`LLM Bridges restarted on port ${this.settings.port}`);
  }
  isApiError(error) {
    return typeof error === "object" && error !== null && "code" in error && "message" in error;
  }
  async handleRequest(req, res) {
    const url = new URL(req.url || "/", `http://127.0.0.1:${this.settings.port}`);
    const path = url.pathname;
    let body = "";
    if (req.method === "POST" || req.method === "PUT") {
      body = await new Promise((resolve) => {
        let data = "";
        req.on("data", (chunk) => data += chunk);
        req.on("end", () => resolve(data));
      });
    }
    if (path === "/" && req.method === "GET") {
      return this.handleStatus(res);
    }
    if (path === "/vault" && req.method === "GET") {
      return this.handleListFiles(res, url.searchParams.get("path") || "");
    }
    if (path === "/vault/read" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleReadFileLegacy(res, data.path);
    }
    if (path === "/vault/write" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleWriteFileLegacy(res, data.path, data.content);
    }
    if (path === "/vault/append" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleAppendFileLegacy(res, data.path, data.content);
    }
    if (path === "/vault/delete" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleDeleteFileLegacy(res, data.path);
    }
    if (path === "/search" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleSearch(res, data.query, data.contextLength || 100);
    }
    if (path === "/active" && req.method === "GET") {
      return this.handleGetActive(res);
    }
    if (path === "/commands" && req.method === "GET") {
      return this.handleListCommands(res);
    }
    if (path === "/commands/execute" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleExecuteCommand(res, data.commandId);
    }
    if (path === "/kb" && req.method === "GET") {
      return this.handleListKnowledgeBases(res);
    }
    if (path === "/kb" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleAddKnowledgeBase(res, data);
    }
    if (path === "/kb" && req.method === "PUT") {
      const data = JSON.parse(body);
      return this.handleUpdateKnowledgeBase(res, data);
    }
    if (path === "/kb/constraint" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleAddFolderConstraint(res, data);
    }
    if (path === "/kb/notes" && req.method === "GET") {
      const kbName = url.searchParams.get("kb");
      const subfolder = url.searchParams.get("subfolder") || void 0;
      return this.handleListNotes(res, kbName || "", subfolder);
    }
    if (path === "/kb/note/create" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleCreateNote(res, data);
    }
    if (path === "/kb/note/read" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleReadNote(res, data);
    }
    if (path === "/kb/note/update" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleUpdateNote(res, data);
    }
    if (path === "/kb/note/append" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleAppendNote(res, data);
    }
    if (path === "/kb/note/move" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleMoveNote(res, data);
    }
    if (path === "/kb/note/delete" && req.method === "POST") {
      const data = JSON.parse(body);
      return this.handleDeleteNote(res, data);
    }
    res.writeHead(404, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ error: "Not found" }));
  }
  // ===========================================================================
  // Status & Legacy Handlers
  // ===========================================================================
  handleStatus(res) {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        status: "ok",
        version: this.manifest.version,
        vault: this.app.vault.getName()
      })
    );
  }
  handleListFiles(res, folderPath) {
    const files = [];
    const listRecursive = (folder, prefix) => {
      for (const child of folder.children) {
        const childPath = prefix ? `${prefix}/${child.name}` : child.name;
        if (child instanceof import_obsidian2.TFile) {
          files.push(childPath);
        } else if (child instanceof import_obsidian2.TFolder) {
          files.push(childPath + "/");
        }
      }
    };
    if (folderPath) {
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (folder instanceof import_obsidian2.TFolder) {
        listRecursive(folder, "");
      } else {
        res.writeHead(404, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Folder not found" }));
        return;
      }
    } else {
      listRecursive(this.app.vault.getRoot(), "");
    }
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ files }));
  }
  async handleReadFileLegacy(res, filePath) {
    var _a;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian2.TFile)) {
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "File not found" }));
      return;
    }
    const content = await this.app.vault.read(file);
    const cache = this.app.metadataCache.getFileCache(file);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        path: file.path,
        content,
        frontmatter: (cache == null ? void 0 : cache.frontmatter) || {},
        tags: ((_a = cache == null ? void 0 : cache.tags) == null ? void 0 : _a.map((t) => t.tag)) || [],
        stat: file.stat
      })
    );
  }
  async handleWriteFileLegacy(res, filePath, content) {
    const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
    if (folderPath) {
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        await this.app.vault.createFolder(folderPath);
      }
    }
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(filePath, content);
    }
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ success: true, path: filePath }));
  }
  async handleAppendFileLegacy(res, filePath, content) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian2.TFile)) {
      return this.handleWriteFileLegacy(res, filePath, content);
    }
    const existingContent = await this.app.vault.read(file);
    const newContent = existingContent.endsWith("\n") ? existingContent + content : existingContent + "\n" + content;
    await this.app.vault.modify(file, newContent);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ success: true, path: filePath }));
  }
  async handleDeleteFileLegacy(res, filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian2.TFile)) {
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "File not found" }));
      return;
    }
    await this.app.vault.delete(file);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ success: true }));
  }
  async handleSearch(res, query, contextLength) {
    const results = [];
    const search = (0, import_obsidian2.prepareSimpleSearch)(query);
    for (const file of this.app.vault.getMarkdownFiles()) {
      const content = await this.app.vault.cachedRead(file);
      const result = search(content);
      if (result) {
        const matches = result.matches.map((match) => ({
          start: match[0],
          end: match[1],
          context: content.slice(
            Math.max(0, match[0] - contextLength),
            match[1] + contextLength
          )
        }));
        results.push({
          path: file.path,
          matches
        });
      }
    }
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ results }));
  }
  handleGetActive(res) {
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "No active file" }));
      return;
    }
    this.handleReadFileLegacy(res, file.path);
  }
  handleListCommands(res) {
    const commands = Object.values(this.app.commands.commands).map((cmd) => ({
      id: cmd.id,
      name: cmd.name
    }));
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ commands }));
  }
  handleExecuteCommand(res, commandId) {
    const cmd = this.app.commands.commands[commandId];
    if (!cmd) {
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Command not found" }));
      return;
    }
    this.app.commands.executeCommandById(commandId);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ success: true }));
  }
  // ===========================================================================
  // Knowledge Base Handlers
  // ===========================================================================
  async handleListKnowledgeBases(res) {
    const kbs = await this.kbManager.listKnowledgeBases();
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ knowledge_bases: kbs }));
  }
  async handleAddKnowledgeBase(res, data) {
    const kb = await this.kbManager.addKnowledgeBase(
      data.name,
      data.description,
      data.subfolder,
      data.organization_rules
    );
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        knowledge_base: kb,
        next_steps: "Knowledge base created. Please define folder constraints using add_knowledge_base_folder_constraint to specify machine-checkable metadata rules for notes under specific subfolders."
      })
    );
  }
  async handleUpdateKnowledgeBase(res, data) {
    const kb = await this.kbManager.updateKnowledgeBase(data.name, {
      description: data.description,
      subfolder: data.subfolder,
      organization_rules: data.organization_rules
    });
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ knowledge_base: kb }));
  }
  async handleAddFolderConstraint(res, data) {
    const schemaValidation = validateConstraintRulesSchema(data.rules);
    if (!schemaValidation.passed) {
      const error = {
        code: "schema_validation_failed",
        message: "Invalid constraint rules schema",
        details: schemaValidation.issues
      };
      res.writeHead(400, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const constraint = await this.kbManager.addFolderConstraint(
      data.kb_name,
      data.subfolder,
      data.rules
    );
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ folder_constraint: constraint }));
  }
  // ===========================================================================
  // Note Handlers (KB-scoped with validation)
  // ===========================================================================
  async handleListNotes(res, kbName, subfolder) {
    const kb = await this.kbManager.getKnowledgeBase(kbName);
    if (!kb) {
      const error = {
        code: "knowledge_base_not_found",
        message: `Knowledge base '${kbName}' not found`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const searchPath = subfolder ? this.kbManager.resolveNotePath(kb, subfolder) : kb.subfolder;
    const notes = [];
    const collectNotes = (folder2) => {
      for (const child of folder2.children) {
        if (child instanceof import_obsidian2.TFile && child.extension === "md") {
          notes.push({ path: child.path });
        } else if (child instanceof import_obsidian2.TFolder) {
          collectNotes(child);
        }
      }
    };
    const folder = this.app.vault.getAbstractFileByPath(searchPath);
    if (folder instanceof import_obsidian2.TFolder) {
      collectNotes(folder);
    }
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        knowledge_base: { name: kb.name, subfolder: kb.subfolder },
        notes
      })
    );
  }
  async handleCreateNote(res, data) {
    const kb = await this.kbManager.getKnowledgeBase(data.knowledge_base_name);
    if (!kb) {
      const error = {
        code: "knowledge_base_not_found",
        message: `Knowledge base '${data.knowledge_base_name}' not found`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const resolvedPath = this.kbManager.resolveNotePath(kb, data.note_path);
    if (this.kbManager.noteExists(resolvedPath)) {
      const error = {
        code: "note_already_exists",
        message: `Note already exists at '${resolvedPath}'`
      };
      res.writeHead(409, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const constraints = await this.kbManager.getFolderConstraints(kb.name);
    const constraint = findApplicableConstraint(resolvedPath, constraints);
    let validation = { passed: true, issues: [] };
    if (constraint) {
      validation = validateNote(resolvedPath, data.note_content, constraint);
      if (!validation.passed) {
        const error = {
          code: "folder_constraint_violation",
          message: "Note does not satisfy folder constraint requirements",
          constraint: {
            kb_name: constraint.kb_name,
            subfolder: constraint.subfolder
          },
          issues: validation.issues
        };
        res.writeHead(400, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error }));
        return;
      }
    }
    const folderPath = resolvedPath.substring(0, resolvedPath.lastIndexOf("/"));
    if (folderPath) {
      await this.ensureFolder(folderPath);
    }
    await this.app.vault.create(resolvedPath, data.note_content);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        knowledge_base: kb,
        note: {
          path: resolvedPath,
          content: data.note_content
        },
        machine_validation: validation,
        validation_instruction_for_llm: VALIDATION_INSTRUCTIONS.create_note
      })
    );
  }
  async handleReadNote(res, data) {
    const kb = await this.kbManager.getKnowledgeBase(data.knowledge_base_name);
    if (!kb) {
      const error = {
        code: "knowledge_base_not_found",
        message: `Knowledge base '${data.knowledge_base_name}' not found`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const resolvedPath = this.kbManager.resolveNotePath(kb, data.note_path);
    const file = this.app.vault.getAbstractFileByPath(resolvedPath);
    if (!(file instanceof import_obsidian2.TFile)) {
      const error = {
        code: "note_not_found",
        message: `Note not found at '${resolvedPath}'`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const fullContent = await this.app.vault.read(file);
    const offset = data.offset || 0;
    const limit = data.limit || DEFAULT_READ_LIMIT;
    const chunk = fullContent.slice(offset, offset + limit);
    const hasMore = offset + limit < fullContent.length;
    const remainingChars = Math.max(0, fullContent.length - (offset + limit));
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        knowledge_base: kb,
        note: {
          path: resolvedPath,
          content: chunk,
          offset,
          next_offset: offset + chunk.length,
          has_more: hasMore,
          remaining_chars: remainingChars
        }
      })
    );
  }
  async handleUpdateNote(res, data) {
    const kb = await this.kbManager.getKnowledgeBase(data.knowledge_base_name);
    if (!kb) {
      const error = {
        code: "knowledge_base_not_found",
        message: `Knowledge base '${data.knowledge_base_name}' not found`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const resolvedPath = this.kbManager.resolveNotePath(kb, data.note_path);
    const file = this.app.vault.getAbstractFileByPath(resolvedPath);
    if (!(file instanceof import_obsidian2.TFile)) {
      const error = {
        code: "note_not_found",
        message: `Note not found at '${resolvedPath}'`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const originalContent = await this.app.vault.read(file);
    const constraints = await this.kbManager.getFolderConstraints(kb.name);
    const constraint = findApplicableConstraint(resolvedPath, constraints);
    let validation = { passed: true, issues: [] };
    if (constraint) {
      validation = validateNote(resolvedPath, data.note_content, constraint);
      if (!validation.passed) {
        const error = {
          code: "folder_constraint_violation",
          message: "Note does not satisfy folder constraint requirements",
          constraint: {
            kb_name: constraint.kb_name,
            subfolder: constraint.subfolder
          },
          issues: validation.issues
        };
        res.writeHead(400, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error }));
        return;
      }
    }
    await this.app.vault.modify(file, data.note_content);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        knowledge_base: kb,
        original_note: {
          path: resolvedPath,
          content: originalContent
        },
        updated_note: {
          path: resolvedPath,
          content: data.note_content
        },
        machine_validation: validation,
        validation_instruction_for_llm: VALIDATION_INSTRUCTIONS.update_note
      })
    );
  }
  async handleAppendNote(res, data) {
    const kb = await this.kbManager.getKnowledgeBase(data.knowledge_base_name);
    if (!kb) {
      const error = {
        code: "knowledge_base_not_found",
        message: `Knowledge base '${data.knowledge_base_name}' not found`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const resolvedPath = this.kbManager.resolveNotePath(kb, data.note_path);
    const file = this.app.vault.getAbstractFileByPath(resolvedPath);
    if (!(file instanceof import_obsidian2.TFile)) {
      const error = {
        code: "note_not_found",
        message: `Note not found at '${resolvedPath}'`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const originalContent = await this.app.vault.read(file);
    const newContent = originalContent.endsWith("\n") ? originalContent + data.note_content : originalContent + "\n" + data.note_content;
    const constraints = await this.kbManager.getFolderConstraints(kb.name);
    const constraint = findApplicableConstraint(resolvedPath, constraints);
    let validation = { passed: true, issues: [] };
    if (constraint) {
      validation = validateNote(resolvedPath, newContent, constraint);
      if (!validation.passed) {
        const error = {
          code: "folder_constraint_violation",
          message: "Note does not satisfy folder constraint requirements",
          constraint: {
            kb_name: constraint.kb_name,
            subfolder: constraint.subfolder
          },
          issues: validation.issues
        };
        res.writeHead(400, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error }));
        return;
      }
    }
    await this.app.vault.modify(file, newContent);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        knowledge_base: kb,
        original_note: {
          path: resolvedPath,
          content: originalContent
        },
        updated_note: {
          path: resolvedPath,
          content: newContent
        },
        machine_validation: validation,
        validation_instruction_for_llm: VALIDATION_INSTRUCTIONS.append_note
      })
    );
  }
  async handleMoveNote(res, data) {
    const kb = await this.kbManager.getKnowledgeBase(data.knowledge_base_name);
    if (!kb) {
      const error = {
        code: "knowledge_base_not_found",
        message: `Knowledge base '${data.knowledge_base_name}' not found`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const originPath = this.kbManager.resolveNotePath(kb, data.origin_note_path);
    const newPath = this.kbManager.resolveNotePath(kb, data.new_note_path);
    const originFile = this.app.vault.getAbstractFileByPath(originPath);
    if (!(originFile instanceof import_obsidian2.TFile)) {
      const error = {
        code: "note_not_found",
        message: `Note not found at '${originPath}'`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    if (this.kbManager.noteExists(newPath)) {
      const error = {
        code: "note_already_exists",
        message: `Note already exists at '${newPath}'`
      };
      res.writeHead(409, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const content = await this.app.vault.read(originFile);
    const constraints = await this.kbManager.getFolderConstraints(kb.name);
    const constraint = findApplicableConstraint(newPath, constraints);
    let validation = { passed: true, issues: [] };
    if (constraint) {
      validation = validateNote(newPath, content, constraint);
      if (!validation.passed) {
        const error = {
          code: "folder_constraint_violation",
          message: "Note does not satisfy folder constraint requirements for new location",
          constraint: {
            kb_name: constraint.kb_name,
            subfolder: constraint.subfolder
          },
          issues: validation.issues
        };
        res.writeHead(400, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error }));
        return;
      }
    }
    const newFolderPath = newPath.substring(0, newPath.lastIndexOf("/"));
    if (newFolderPath) {
      await this.ensureFolder(newFolderPath);
    }
    await this.app.vault.rename(originFile, newPath);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        knowledge_base: kb,
        origin_path: originPath,
        new_path: newPath,
        machine_validation: validation,
        validation_instruction_for_llm: VALIDATION_INSTRUCTIONS.move_note
      })
    );
  }
  async handleDeleteNote(res, data) {
    const kb = await this.kbManager.getKnowledgeBase(data.knowledge_base_name);
    if (!kb) {
      const error = {
        code: "knowledge_base_not_found",
        message: `Knowledge base '${data.knowledge_base_name}' not found`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    const resolvedPath = this.kbManager.resolveNotePath(kb, data.note_path);
    const file = this.app.vault.getAbstractFileByPath(resolvedPath);
    if (!(file instanceof import_obsidian2.TFile)) {
      const error = {
        code: "note_not_found",
        message: `Note not found at '${resolvedPath}'`
      };
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error }));
      return;
    }
    await this.app.vault.delete(file);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        knowledge_base: { name: kb.name, subfolder: kb.subfolder },
        deleted_path: resolvedPath
      })
    );
  }
  // ===========================================================================
  // Utility Methods
  // ===========================================================================
  async ensureFolder(path) {
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing)
      return;
    const parts = path.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const folder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  copyMCPConfig() {
    const config = {
      mcpServers: {
        obsidian: {
          command: "npx",
          args: ["-y", "obsidian-llm-bridges"],
          env: {
            OBSIDIAN_API_URL: `http://127.0.0.1:${this.settings.port}`,
            OBSIDIAN_API_KEY: this.settings.apiKey
          }
        }
      }
    };
    navigator.clipboard.writeText(JSON.stringify(config, null, 2));
    new import_obsidian2.Notice("MCP configuration copied to clipboard!");
  }
};
var LLMBridgesSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "LLM Bridges Settings" });
    const statusEl = containerEl.createEl("div", { cls: "llm-bridges-status" });
    statusEl.createEl("p", {
      text: `Server running on http://127.0.0.1:${this.plugin.settings.port}`
    });
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Used to authenticate requests to the server").addText(
      (text) => text.setValue(this.plugin.settings.apiKey).setDisabled(true)
    ).addButton(
      (btn) => btn.setButtonText("Copy").onClick(() => {
        navigator.clipboard.writeText(this.plugin.settings.apiKey);
        new import_obsidian2.Notice("API Key copied!");
      })
    ).addButton(
      (btn) => btn.setButtonText("Regenerate").onClick(async () => {
        this.plugin.settings.apiKey = this.plugin.generateApiKey();
        await this.plugin.saveSettings();
        this.display();
        new import_obsidian2.Notice("API Key regenerated!");
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Port").setDesc("Port for the HTTP server (requires restart)").addText(
      (text) => text.setValue(String(this.plugin.settings.port)).onChange(async (value) => {
        const port = parseInt(value);
        if (!isNaN(port) && port > 0 && port < 65536) {
          this.plugin.settings.port = port;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Restart Server").setDesc("Apply port changes").addButton(
      (btn) => btn.setButtonText("Restart").onClick(() => {
        this.plugin.restartServer();
      })
    );
    containerEl.createEl("h3", { text: "Claude Setup" });
    const instructionsEl = containerEl.createEl("div");
    instructionsEl.createEl("p", {
      text: "Add this to your Claude Desktop configuration:"
    });
    const configEl = containerEl.createEl("pre", {
      cls: "llm-bridges-config"
    });
    configEl.setText(`{
  "mcpServers": {
    "obsidian": {
      "command": "npx",
      "args": ["-y", "obsidian-llm-bridges"],
      "env": {
        "OBSIDIAN_API_URL": "http://127.0.0.1:${this.plugin.settings.port}",
        "OBSIDIAN_API_KEY": "${this.plugin.settings.apiKey}"
      }
    }
  }
}`);
    new import_obsidian2.Setting(containerEl).addButton(
      (btn) => btn.setButtonText("Copy MCP Configuration").setCta().onClick(() => this.plugin.copyMCPConfig())
    );
    containerEl.createEl("h4", { text: "Config File Locations" });
    const locationsEl = containerEl.createEl("ul");
    locationsEl.createEl("li", {
      text: "macOS: ~/Library/Application Support/Claude/claude_desktop_config.json"
    });
    locationsEl.createEl("li", {
      text: "Windows: %APPDATA%\\Claude\\claude_desktop_config.json"
    });
  }
};
