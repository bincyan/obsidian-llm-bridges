/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LLMBridgesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var http2 = __toESM(require("http"), 1);

// src/kb-manager.ts
var import_obsidian = require("obsidian");

// src/types.ts
var LLM_BRIDGES_DIR = ".llm_bridges";
var KNOWLEDGE_BASE_DIR = "knowledge_base";
var FOLDER_CONSTRAINTS_DIR = "folder_constraints";
var META_FILE = "meta.md";
var DEFAULT_READ_LIMIT = 1e4;

// src/kb-manager.ts
var KBManager = class {
  constructor(app) {
    this.app = app;
  }
  // ============================================================================
  // Path Helpers
  // ============================================================================
  /**
   * Get the base path for all KB storage
   */
  getKBBasePath() {
    return `${LLM_BRIDGES_DIR}/${KNOWLEDGE_BASE_DIR}`;
  }
  /**
   * Get the path for a specific KB's directory
   */
  getKBPath(kbName) {
    return `${this.getKBBasePath()}/${kbName}`;
  }
  /**
   * Get the path for a KB's meta.md file
   */
  getMetaPath(kbName) {
    return `${this.getKBPath(kbName)}/${META_FILE}`;
  }
  /**
   * Get the path for a KB's folder_constraints directory
   */
  getConstraintsPath(kbName) {
    return `${this.getKBPath(kbName)}/${FOLDER_CONSTRAINTS_DIR}`;
  }
  // ============================================================================
  // Knowledge Base Operations
  // ============================================================================
  /**
   * List all Knowledge Bases
   */
  async listKnowledgeBases() {
    const basePath = this.getKBBasePath();
    const baseFolder = this.app.vault.getAbstractFileByPath(basePath);
    if (!(baseFolder instanceof import_obsidian.TFolder)) {
      return [];
    }
    const kbs = [];
    for (const child of baseFolder.children) {
      if (child instanceof import_obsidian.TFolder) {
        try {
          const kb = await this.getKnowledgeBase(child.name);
          if (kb) {
            kbs.push({
              name: kb.name,
              description: kb.description,
              subfolder: kb.subfolder,
              create_time: kb.create_time,
              organization_rules_preview: kb.organization_rules.slice(0, 200) + (kb.organization_rules.length > 200 ? "..." : "")
            });
          }
        } catch (e) {
        }
      }
    }
    return kbs;
  }
  /**
   * Get a single Knowledge Base by name
   */
  async getKnowledgeBase(name) {
    const metaPath = this.getMetaPath(name);
    const file = this.app.vault.getAbstractFileByPath(metaPath);
    if (!(file instanceof import_obsidian.TFile)) {
      return null;
    }
    const content = await this.app.vault.read(file);
    return this.parseKBMeta(name, content);
  }
  /**
   * Add a new Knowledge Base
   */
  async addKnowledgeBase(name, description, subfolder, organizationRules) {
    const existing = await this.getKnowledgeBase(name);
    if (existing) {
      throw this.createError("knowledge_base_already_exists", `Knowledge base '${name}' already exists`);
    }
    const allKBs = await this.listKnowledgeBases();
    for (const kb2 of allKBs) {
      if (this.subfolderOverlaps(subfolder, kb2.subfolder)) {
        throw this.createError(
          "subfolder_overlap",
          `Subfolder '${subfolder}' overlaps with KB '${kb2.name}' subfolder '${kb2.subfolder}'`
        );
      }
    }
    const kbPath = this.getKBPath(name);
    const constraintsPath = this.getConstraintsPath(name);
    await this.ensureFolder(kbPath);
    await this.ensureFolder(constraintsPath);
    const kb = {
      name,
      create_time: new Date().toISOString(),
      description,
      subfolder: this.normalizePath(subfolder),
      organization_rules: organizationRules
    };
    const metaContent = this.serializeKBMeta(kb);
    await this.app.vault.create(this.getMetaPath(name), metaContent);
    await this.ensureFolder(kb.subfolder);
    return kb;
  }
  /**
   * Update an existing Knowledge Base
   */
  async updateKnowledgeBase(name, updates) {
    var _a, _b;
    const kb = await this.getKnowledgeBase(name);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${name}' not found`);
    }
    if (updates.subfolder && updates.subfolder !== kb.subfolder) {
      const allKBs = await this.listKnowledgeBases();
      for (const otherKb of allKBs) {
        if (otherKb.name !== name && this.subfolderOverlaps(updates.subfolder, otherKb.subfolder)) {
          throw this.createError(
            "subfolder_overlap",
            `Subfolder '${updates.subfolder}' overlaps with KB '${otherKb.name}' subfolder '${otherKb.subfolder}'`
          );
        }
      }
    }
    const updatedKB = {
      ...kb,
      description: (_a = updates.description) != null ? _a : kb.description,
      subfolder: updates.subfolder ? this.normalizePath(updates.subfolder) : kb.subfolder,
      organization_rules: (_b = updates.organization_rules) != null ? _b : kb.organization_rules
    };
    const metaPath = this.getMetaPath(name);
    const file = this.app.vault.getAbstractFileByPath(metaPath);
    if (file instanceof import_obsidian.TFile) {
      await this.app.vault.modify(file, this.serializeKBMeta(updatedKB));
    }
    if (updates.subfolder) {
      await this.ensureFolder(updatedKB.subfolder);
    }
    return updatedKB;
  }
  // ============================================================================
  // Folder Constraint Operations
  // ============================================================================
  /**
   * Get all folder constraints for a KB
   */
  async getFolderConstraints(kbName) {
    const kb = await this.getKnowledgeBase(kbName);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${kbName}' not found`);
    }
    const constraintsPath = this.getConstraintsPath(kbName);
    const folder = this.app.vault.getAbstractFileByPath(constraintsPath);
    if (!(folder instanceof import_obsidian.TFolder)) {
      return [];
    }
    const constraints = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile && child.extension === "md") {
        try {
          const content = await this.app.vault.read(child);
          const constraint = this.parseConstraint(kbName, content);
          if (constraint) {
            constraints.push(constraint);
          }
        } catch (e) {
        }
      }
    }
    return constraints;
  }
  /**
   * Add a folder constraint to a KB
   */
  async addFolderConstraint(kbName, subfolder, rules) {
    const kb = await this.getKnowledgeBase(kbName);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${kbName}' not found`);
    }
    const normalizedSubfolder = this.normalizePath(subfolder);
    if (!normalizedSubfolder.startsWith(kb.subfolder)) {
      throw this.createError(
        "invalid_note_path",
        `Subfolder '${subfolder}' is outside KB's scope '${kb.subfolder}'`
      );
    }
    const constraint = {
      kb_name: kbName,
      subfolder: normalizedSubfolder,
      rules
    };
    const constraintsPath = this.getConstraintsPath(kbName);
    await this.ensureFolder(constraintsPath);
    const filename = this.sanitizeFilename(normalizedSubfolder) + ".md";
    const filePath = `${constraintsPath}/${filename}`;
    const content = this.serializeConstraint(constraint);
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(filePath, content);
    }
    return constraint;
  }
  // ============================================================================
  // Note Path Validation
  // ============================================================================
  /**
   * Resolve and validate a note path within a KB's scope
   */
  resolveNotePath(kb, notePath) {
    let resolved = notePath;
    if (!resolved.startsWith(kb.subfolder + "/") && resolved !== kb.subfolder) {
      resolved = `${kb.subfolder}/${notePath}`;
    }
    resolved = this.normalizePath(resolved);
    if (!resolved.startsWith(kb.subfolder + "/") && resolved !== kb.subfolder) {
      throw this.createError("invalid_note_path", `Path '${notePath}' is outside KB scope '${kb.subfolder}'`);
    }
    if (resolved.includes("..")) {
      throw this.createError("invalid_note_path", "Path traversal not allowed");
    }
    return resolved;
  }
  /**
   * Check if a note exists
   */
  noteExists(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    return file instanceof import_obsidian.TFile;
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  /**
   * Parse KB meta.md content into KnowledgeBase object
   */
  parseKBMeta(name, content) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      throw new Error("Invalid meta.md format");
    }
    const frontmatter = this.parseSimpleYaml(match[1]);
    const organizationRules = match[2].trim();
    return {
      name,
      create_time: String(frontmatter.create_time || new Date().toISOString()),
      description: String(frontmatter.description || ""),
      subfolder: String(frontmatter.subfolder || ""),
      organization_rules: organizationRules
    };
  }
  /**
   * Serialize KnowledgeBase to meta.md content
   */
  serializeKBMeta(kb) {
    return `---
create_time: "${kb.create_time}"
description: "${kb.description.replace(/"/g, '\\"')}"
subfolder: "${kb.subfolder}"
---

${kb.organization_rules}`;
  }
  /**
   * Parse constraint file content
   */
  parseConstraint(kbName, content) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return null;
    }
    const frontmatter = this.parseSimpleYaml(match[1]);
    const body = match[2];
    const rulesMatch = body.match(/```ya?ml\r?\n([\s\S]*?)\r?\n```/);
    let rules = {};
    if (rulesMatch) {
      try {
        rules = this.parseRulesYaml(rulesMatch[1]);
      } catch (e) {
      }
    }
    return {
      kb_name: kbName,
      subfolder: String(frontmatter.subfolder || ""),
      rules
    };
  }
  /**
   * Serialize constraint to markdown
   */
  serializeConstraint(constraint) {
    const rulesYaml = this.serializeRulesYaml(constraint.rules);
    return `---
subfolder: "${constraint.subfolder}"
---

## Rules

\`\`\`yaml
${rulesYaml}
\`\`\`
`;
  }
  /**
   * Simple YAML parser
   */
  parseSimpleYaml(yaml) {
    const result = {};
    const lines = yaml.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      const colonIndex = trimmed.indexOf(":");
      if (colonIndex > 0) {
        const key = trimmed.slice(0, colonIndex).trim();
        let value = trimmed.slice(colonIndex + 1).trim();
        if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        result[key] = value;
      }
    }
    return result;
  }
  /**
   * Parse rules YAML - handles nested structure
   */
  parseRulesYaml(yaml) {
    const rules = {};
    const lines = yaml.split("\n");
    let currentSection = null;
    let currentField = null;
    const fields = [];
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      if (!line.startsWith(" ") && !line.startsWith("	")) {
        if (currentSection === "frontmatter" && fields.length > 0) {
          rules.frontmatter = { required_fields: fields.slice() };
        }
        const colonIdx = trimmed.indexOf(":");
        if (colonIdx > 0) {
          currentSection = trimmed.slice(0, colonIdx).trim();
          const value = trimmed.slice(colonIdx + 1).trim();
          if (currentSection === "filename" && value) {
          }
        }
        currentField = null;
        fields.length = 0;
        continue;
      }
      if (currentSection === "frontmatter") {
        if (trimmed.startsWith("- name:")) {
          if (currentField) {
            fields.push(currentField);
          }
          currentField = { name: trimmed.slice(8).trim(), type: "string" };
        } else if (currentField && trimmed.includes(":")) {
          const [key, ...valueParts] = trimmed.split(":");
          const keyName = key.trim();
          let value = valueParts.join(":").trim();
          if (value === "true")
            value = true;
          else if (value === "false")
            value = false;
          else if (value.startsWith("[") && value.endsWith("]")) {
            const arrayStr = value.slice(1, -1);
            value = arrayStr.split(",").map((v) => {
              const trimmedV = v.trim().replace(/^["']|["']$/g, "");
              if (trimmedV === "true")
                return true;
              if (trimmedV === "false")
                return false;
              const num = Number(trimmedV);
              if (!isNaN(num))
                return num;
              return trimmedV;
            });
          } else if (value.startsWith('"') || value.startsWith("'")) {
            value = value.slice(1, -1);
          }
          if (keyName === "type") {
            currentField.type = value;
          } else if (keyName === "pattern") {
            currentField.pattern = value;
          } else if (keyName === "allowed_values") {
            currentField.allowed_values = value;
          }
        }
      } else if (currentSection === "filename") {
        if (trimmed.startsWith("pattern:")) {
          const pattern = trimmed.slice(8).trim().replace(/^["']|["']$/g, "");
          rules.filename = { pattern };
        }
      } else if (currentSection === "content") {
        if (!rules.content)
          rules.content = {};
        const colonIdx = trimmed.indexOf(":");
        if (colonIdx > 0) {
          const key = trimmed.slice(0, colonIdx).trim();
          const value = trimmed.slice(colonIdx + 1).trim();
          if (key === "min_length" || key === "max_length") {
            rules.content[key] = parseInt(value) || 0;
          } else if (key === "required_sections") {
            const arr = value.slice(1, -1).split(",").map((v) => v.trim().replace(/^["']|["']$/g, ""));
            rules.content[key] = arr;
          }
        }
      }
    }
    if (currentSection === "frontmatter") {
      if (currentField) {
        fields.push(currentField);
      }
      if (fields.length > 0) {
        rules.frontmatter = { required_fields: fields };
      }
    }
    return rules;
  }
  /**
   * Serialize rules to YAML
   */
  serializeRulesYaml(rules) {
    var _a, _b;
    const lines = [];
    if ((_a = rules.frontmatter) == null ? void 0 : _a.required_fields) {
      lines.push("frontmatter:");
      lines.push("  required_fields:");
      for (const field of rules.frontmatter.required_fields) {
        lines.push(`    - name: ${field.name}`);
        lines.push(`      type: ${field.type}`);
        if (field.pattern) {
          lines.push(`      pattern: "${field.pattern}"`);
        }
        if (field.allowed_values) {
          const values = field.allowed_values.map(
            (v) => typeof v === "string" ? `"${v}"` : String(v)
          ).join(", ");
          lines.push(`      allowed_values: [${values}]`);
        }
      }
    }
    if ((_b = rules.filename) == null ? void 0 : _b.pattern) {
      lines.push("filename:");
      lines.push(`  pattern: "${rules.filename.pattern}"`);
    }
    if (rules.content) {
      lines.push("content:");
      if (rules.content.min_length !== void 0) {
        lines.push(`  min_length: ${rules.content.min_length}`);
      }
      if (rules.content.max_length !== void 0) {
        lines.push(`  max_length: ${rules.content.max_length}`);
      }
      if (rules.content.required_sections) {
        const sections = rules.content.required_sections.map((s) => `"${s}"`).join(", ");
        lines.push(`  required_sections: [${sections}]`);
      }
    }
    return lines.join("\n");
  }
  // ============================================================================
  // Utility Methods
  // ============================================================================
  /**
   * Ensure a folder exists, creating it if necessary
   */
  async ensureFolder(path) {
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing)
      return;
    const parts = path.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const folder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  /**
   * Normalize a path (remove leading/trailing slashes, etc.)
   */
  normalizePath(path) {
    return path.replace(/^\/+|\/+$/g, "").replace(/\/+/g, "/");
  }
  /**
   * Check if two subfolders overlap
   */
  subfolderOverlaps(a, b) {
    const normA = this.normalizePath(a);
    const normB = this.normalizePath(b);
    return normA.startsWith(normB + "/") || normB.startsWith(normA + "/") || normA === normB;
  }
  /**
   * Create a safe filename from a path
   */
  sanitizeFilename(path) {
    return path.replace(/\//g, "_").replace(/[^a-zA-Z0-9_-]/g, "");
  }
  /**
   * Create an API error
   */
  createError(code, message, details) {
    return { code, message, details };
  }
};

// src/validation.ts
function parseNote(content) {
  const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
  const match = content.match(frontmatterRegex);
  if (!match) {
    return {
      frontmatter: {},
      body: content,
      raw: content
    };
  }
  const frontmatterYaml = match[1];
  const body = match[2] || "";
  const frontmatter = parseSimpleYaml(frontmatterYaml);
  return {
    frontmatter,
    body,
    raw: content
  };
}
function parseSimpleYaml(yaml) {
  const result = {};
  const lines = yaml.split("\n");
  let currentKey = null;
  let currentArray = null;
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#"))
      continue;
    if (trimmed.startsWith("- ") && currentKey && currentArray) {
      const value = trimmed.slice(2).trim();
      currentArray.push(parseYamlValue(value));
      continue;
    }
    const colonIndex = trimmed.indexOf(":");
    if (colonIndex > 0) {
      const key = trimmed.slice(0, colonIndex).trim();
      const value = trimmed.slice(colonIndex + 1).trim();
      if (currentKey && currentArray) {
        result[currentKey] = currentArray;
        currentArray = null;
      }
      if (value === "" || value === "[]") {
        currentKey = key;
        currentArray = [];
      } else if (value.startsWith("[") && value.endsWith("]")) {
        const arrayContent = value.slice(1, -1);
        result[key] = arrayContent.split(",").map((v) => parseYamlValue(v.trim())).filter((v) => v !== "");
        currentKey = null;
        currentArray = null;
      } else {
        result[key] = parseYamlValue(value);
        currentKey = null;
        currentArray = null;
      }
    }
  }
  if (currentKey && currentArray) {
    result[currentKey] = currentArray;
  }
  return result;
}
function parseYamlValue(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  if (value === "null" || value === "~")
    return null;
  const num = Number(value);
  if (!isNaN(num) && value !== "")
    return num;
  return value;
}
function validateNote(notePath, content, constraint) {
  var _a, _b;
  const issues = [];
  const parsed = parseNote(content);
  const filename = notePath.split("/").pop() || "";
  if ((_a = constraint.rules.frontmatter) == null ? void 0 : _a.required_fields) {
    for (const field of constraint.rules.frontmatter.required_fields) {
      const fieldIssues = validateFrontmatterField(parsed.frontmatter, field);
      issues.push(...fieldIssues);
    }
  }
  if ((_b = constraint.rules.filename) == null ? void 0 : _b.pattern) {
    const filenameIssues = validateFilename(filename, constraint.rules.filename.pattern);
    issues.push(...filenameIssues);
  }
  if (constraint.rules.content) {
    const contentIssues = validateContent(parsed.body, constraint.rules.content);
    issues.push(...contentIssues);
  }
  return {
    passed: issues.length === 0,
    issues
  };
}
function validateFrontmatterField(frontmatter, field) {
  const issues = [];
  const value = frontmatter[field.name];
  const fieldPath = `frontmatter.${field.name}`;
  if (value === void 0 || value === null) {
    issues.push({
      field: fieldPath,
      error: "missing_required_field",
      message: `Required field '${field.name}' is missing`
    });
    return issues;
  }
  const typeValid = validateFieldType(value, field.type);
  if (!typeValid) {
    issues.push({
      field: fieldPath,
      error: "invalid_field_type",
      expected: field.type,
      actual: typeof value,
      message: `Field '${field.name}' should be type '${field.type}', got '${typeof value}'`
    });
    return issues;
  }
  if (field.pattern && typeof value === "string") {
    try {
      const regex = new RegExp(field.pattern);
      if (!regex.test(value)) {
        issues.push({
          field: fieldPath,
          error: "pattern_mismatch",
          pattern: field.pattern,
          actual: value,
          message: `Field '${field.name}' does not match pattern '${field.pattern}'`
        });
      }
    } catch (e) {
    }
  }
  if (field.allowed_values && field.allowed_values.length > 0) {
    if (!field.allowed_values.includes(value)) {
      issues.push({
        field: fieldPath,
        error: "invalid_value",
        expected: field.allowed_values,
        actual: value,
        message: `Field '${field.name}' must be one of: ${field.allowed_values.join(", ")}`
      });
    }
  }
  return issues;
}
function validateFieldType(value, expectedType) {
  switch (expectedType) {
    case "string":
      return typeof value === "string";
    case "number":
      return typeof value === "number";
    case "boolean":
      return typeof value === "boolean";
    case "date":
      if (typeof value === "string") {
        return /^\d{4}-\d{2}-\d{2}/.test(value);
      }
      return value instanceof Date;
    case "array":
      return Array.isArray(value);
    default:
      return true;
  }
}
function validateFilename(filename, pattern) {
  const issues = [];
  try {
    const regex = new RegExp(pattern);
    if (!regex.test(filename)) {
      issues.push({
        field: "filename",
        error: "pattern_mismatch",
        pattern,
        actual: filename,
        message: `Filename '${filename}' does not match pattern '${pattern}'`
      });
    }
  } catch (e) {
  }
  return issues;
}
function validateContent(body, rules) {
  const issues = [];
  if (!rules)
    return issues;
  if (rules.min_length !== void 0 && body.length < rules.min_length) {
    issues.push({
      field: "content",
      error: "content_too_short",
      expected: rules.min_length,
      actual: body.length,
      message: `Content must be at least ${rules.min_length} characters, got ${body.length}`
    });
  }
  if (rules.max_length !== void 0 && body.length > rules.max_length) {
    issues.push({
      field: "content",
      error: "content_too_long",
      expected: rules.max_length,
      actual: body.length,
      message: `Content must be at most ${rules.max_length} characters, got ${body.length}`
    });
  }
  if (rules.required_sections) {
    for (const section of rules.required_sections) {
      const headingRegex = new RegExp(`^#+\\s+${escapeRegex(section)}\\s*$`, "im");
      if (!headingRegex.test(body)) {
        issues.push({
          field: "content.sections",
          error: "missing_section",
          expected: section,
          message: `Required section '${section}' is missing`
        });
      }
    }
  }
  return issues;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function findApplicableConstraint(notePath, constraints) {
  let bestMatch = null;
  let bestMatchLength = -1;
  for (const constraint of constraints) {
    const constraintPath = constraint.subfolder.replace(/\/$/, "");
    const noteDir = notePath.substring(0, notePath.lastIndexOf("/"));
    if (notePath.startsWith(constraintPath + "/") || noteDir === constraintPath) {
      if (constraintPath.length > bestMatchLength) {
        bestMatch = constraint;
        bestMatchLength = constraintPath.length;
      }
    }
  }
  return bestMatch;
}
function validateConstraintRulesSchema(rules) {
  const issues = [];
  if (!rules || typeof rules !== "object") {
    issues.push({
      field: "rules",
      error: "invalid_field_type",
      expected: "object",
      actual: typeof rules,
      message: "Rules must be an object"
    });
    return { passed: false, issues };
  }
  const rulesObj = rules;
  if (rulesObj.frontmatter !== void 0) {
    if (typeof rulesObj.frontmatter !== "object") {
      issues.push({
        field: "rules.frontmatter",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.frontmatter
      });
    } else {
      const fm = rulesObj.frontmatter;
      if (fm.required_fields !== void 0 && !Array.isArray(fm.required_fields)) {
        issues.push({
          field: "rules.frontmatter.required_fields",
          error: "invalid_field_type",
          expected: "array",
          actual: typeof fm.required_fields
        });
      }
    }
  }
  if (rulesObj.filename !== void 0) {
    if (typeof rulesObj.filename !== "object") {
      issues.push({
        field: "rules.filename",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.filename
      });
    } else {
      const fn = rulesObj.filename;
      if (fn.pattern !== void 0 && typeof fn.pattern !== "string") {
        issues.push({
          field: "rules.filename.pattern",
          error: "invalid_field_type",
          expected: "string",
          actual: typeof fn.pattern
        });
      }
      if (typeof fn.pattern === "string") {
        try {
          new RegExp(fn.pattern);
        } catch (e) {
          issues.push({
            field: "rules.filename.pattern",
            error: "invalid_value",
            actual: fn.pattern,
            message: "Invalid regex pattern"
          });
        }
      }
    }
  }
  if (rulesObj.content !== void 0) {
    if (typeof rulesObj.content !== "object") {
      issues.push({
        field: "rules.content",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.content
      });
    }
  }
  return {
    passed: issues.length === 0,
    issues
  };
}

// src/oauth.ts
var crypto = __toESM(require("crypto"), 1);
var DEFAULT_OAUTH_SETTINGS = {
  enabled: false,
  clients: [],
  access_token_lifetime: 3600,
  refresh_token_lifetime: 604800,
  authorization_code_lifetime: 600,
  chatgpt_gpt_id: ""
  // Set this to your Custom GPT ID (e.g., "g-abc123")
};
var CLAUDE_DESKTOP_CLIENT = {
  client_id: "claude-desktop",
  client_name: "Claude Desktop MCP Connector",
  redirect_uris: [
    "https://claude.ai/api/oauth/callback",
    // Claude web callback (exact match required)
    "claude://oauth/callback"
    // Claude desktop app deep link (exact match required)
  ],
  grant_types: ["authorization_code"],
  response_types: ["code"],
  token_endpoint_auth_method: "none",
  // Public client - no secret
  pkce_required: true,
  // PKCE with S256 is mandatory
  created_at: new Date().toISOString(),
  scope: "mcp:read mcp:write"
};
function createChatGPTClient(gptId) {
  const redirectUris = [
    `https://chat.openai.com/aip/${gptId}/oauth/callback`,
    `https://chatgpt.com/aip/${gptId}/oauth/callback`
  ];
  return {
    client_id: `chatgpt-${gptId}`,
    client_name: `ChatGPT Custom GPT (${gptId})`,
    redirect_uris: redirectUris,
    grant_types: ["authorization_code", "refresh_token"],
    response_types: ["code"],
    token_endpoint_auth_method: "none",
    // Public client - using PKCE
    pkce_required: true,
    // PKCE with S256 is required
    created_at: new Date().toISOString(),
    scope: "mcp:read mcp:write"
  };
}
function isChatGPTClient(clientId) {
  return clientId.startsWith("chatgpt-");
}
function getAuthorizationServerMetadata(baseUrl) {
  return {
    issuer: baseUrl,
    authorization_endpoint: `${baseUrl}/oauth/authorize`,
    token_endpoint: `${baseUrl}/oauth/token`,
    token_endpoint_auth_methods_supported: ["none"],
    // Public clients (PKCE)
    grant_types_supported: ["authorization_code", "refresh_token"],
    response_types_supported: ["code"],
    code_challenge_methods_supported: ["S256"],
    scopes_supported: ["mcp:read", "mcp:write", "mcp:admin"],
    service_documentation: "https://github.com/bincyan/obsidian-llm-bridges"
  };
}
function getProtectedResourceMetadata(baseUrl) {
  return {
    resource: baseUrl,
    authorization_servers: [baseUrl],
    bearer_methods_supported: ["header"],
    scopes_supported: ["mcp:read", "mcp:write", "mcp:admin"]
  };
}
var OAuthManager = class {
  constructor(settings, saveCallback) {
    this.authorizationCodes = /* @__PURE__ */ new Map();
    this.accessTokens = /* @__PURE__ */ new Map();
    this.refreshTokens = /* @__PURE__ */ new Map();
    this.settings = settings;
    this.saveCallback = saveCallback;
    if (settings.enabled) {
      if (!settings.clients.find((c) => c.client_id === "claude-desktop")) {
        this.registerClient(CLAUDE_DESKTOP_CLIENT);
      }
      if (settings.chatgpt_gpt_id) {
        this.registerOrUpdateChatGPTClient(settings.chatgpt_gpt_id);
      }
    }
  }
  /**
   * Register or update the ChatGPT client with the given GPT ID.
   * This ensures the redirect URIs match the current GPT ID.
   */
  async registerOrUpdateChatGPTClient(gptId) {
    if (!gptId)
      return null;
    const newClientId = `chatgpt-${gptId}`;
    this.settings.clients = this.settings.clients.filter(
      (c) => !isChatGPTClient(c.client_id) || c.client_id === newClientId
    );
    const existing = this.settings.clients.find((c) => c.client_id === newClientId);
    if (existing) {
      return existing;
    }
    const chatgptClient = createChatGPTClient(gptId);
    this.settings.clients.push(chatgptClient);
    await this.saveCallback(this.settings);
    return chatgptClient;
  }
  // ============================================================================
  // Client Management
  // ============================================================================
  async registerClient(client) {
    const existing = this.settings.clients.find((c) => c.client_id === client.client_id);
    if (existing) {
      return existing;
    }
    this.settings.clients.push(client);
    await this.saveCallback(this.settings);
    return client;
  }
  getClient(clientId) {
    return this.settings.clients.find((c) => c.client_id === clientId);
  }
  validateRedirectUri(clientId, redirectUri) {
    const client = this.getClient(clientId);
    if (!client)
      return false;
    return client.redirect_uris.includes(redirectUri);
  }
  // ============================================================================
  // Authorization Code Flow
  // ============================================================================
  generateAuthorizationCode(clientId, redirectUri, codeChallenge, codeChallengeMethod, scope) {
    const code = this.generateSecureToken(32);
    const expiresAt = Date.now() + this.settings.authorization_code_lifetime * 1e3;
    const authCode = {
      code,
      client_id: clientId,
      redirect_uri: redirectUri,
      code_challenge: codeChallenge,
      code_challenge_method: codeChallengeMethod,
      scope,
      expires_at: expiresAt,
      user_approved: false
    };
    this.authorizationCodes.set(code, authCode);
    return authCode;
  }
  approveAuthorizationCode(code) {
    const authCode = this.authorizationCodes.get(code);
    if (!authCode)
      return false;
    authCode.user_approved = true;
    return true;
  }
  denyAuthorizationCode(code) {
    this.authorizationCodes.delete(code);
  }
  getAuthorizationCode(code) {
    const authCode = this.authorizationCodes.get(code);
    if (!authCode)
      return void 0;
    if (Date.now() > authCode.expires_at) {
      this.authorizationCodes.delete(code);
      return void 0;
    }
    return authCode;
  }
  // ============================================================================
  // Token Exchange
  // ============================================================================
  exchangeCodeForTokens(code, clientId, redirectUri, codeVerifier) {
    const authCode = this.getAuthorizationCode(code);
    if (!authCode) {
      return { error: "invalid_grant", error_description: "Authorization code not found or expired" };
    }
    if (!authCode.user_approved) {
      return { error: "access_denied", error_description: "Authorization not approved by user" };
    }
    if (authCode.client_id !== clientId) {
      return { error: "invalid_grant", error_description: "Client ID mismatch" };
    }
    if (authCode.redirect_uri !== redirectUri) {
      return { error: "invalid_grant", error_description: "Redirect URI mismatch" };
    }
    if (!this.verifyCodeChallenge(codeVerifier, authCode.code_challenge)) {
      return { error: "invalid_grant", error_description: "Invalid code verifier" };
    }
    this.authorizationCodes.delete(code);
    const accessToken = this.generateAccessToken(clientId, authCode.scope);
    const refreshToken = this.generateRefreshToken(clientId, authCode.scope);
    accessToken.refresh_token = refreshToken.refresh_token;
    return { access_token: accessToken, refresh_token: refreshToken };
  }
  refreshAccessToken(refreshTokenStr, clientId) {
    const refreshToken = this.refreshTokens.get(refreshTokenStr);
    if (!refreshToken) {
      return { error: "invalid_grant", error_description: "Refresh token not found" };
    }
    if (Date.now() > refreshToken.expires_at) {
      this.refreshTokens.delete(refreshTokenStr);
      return { error: "invalid_grant", error_description: "Refresh token expired" };
    }
    if (refreshToken.client_id !== clientId) {
      return { error: "invalid_grant", error_description: "Client ID mismatch" };
    }
    const newAccessToken = this.generateAccessToken(clientId, refreshToken.scope);
    this.refreshTokens.delete(refreshTokenStr);
    const newRefreshToken = this.generateRefreshToken(clientId, refreshToken.scope);
    newAccessToken.refresh_token = newRefreshToken.refresh_token;
    return { access_token: newAccessToken, refresh_token: newRefreshToken };
  }
  // ============================================================================
  // Token Validation
  // ============================================================================
  validateAccessToken(tokenStr) {
    const token = this.accessTokens.get(tokenStr);
    if (!token)
      return null;
    if (Date.now() > token.expires_at) {
      this.accessTokens.delete(tokenStr);
      return null;
    }
    return token;
  }
  revokeToken(tokenStr) {
    const accessDeleted = this.accessTokens.delete(tokenStr);
    const refreshDeleted = this.refreshTokens.delete(tokenStr);
    return accessDeleted || refreshDeleted;
  }
  revokeAllClientTokens(clientId) {
    for (const [key, token] of this.accessTokens) {
      if (token.client_id === clientId) {
        this.accessTokens.delete(key);
      }
    }
    for (const [key, token] of this.refreshTokens) {
      if (token.client_id === clientId) {
        this.refreshTokens.delete(key);
      }
    }
  }
  // ============================================================================
  // PKCE Helpers
  // ============================================================================
  verifyCodeChallenge(codeVerifier, codeChallenge) {
    const hash = crypto.createHash("sha256").update(codeVerifier).digest();
    const computed = this.base64UrlEncode(hash);
    return computed === codeChallenge;
  }
  base64UrlEncode(buffer) {
    return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  // ============================================================================
  // Token Generation
  // ============================================================================
  generateAccessToken(clientId, scope) {
    const tokenStr = this.generateSecureToken(32);
    const expiresIn = this.settings.access_token_lifetime;
    const expiresAt = Date.now() + expiresIn * 1e3;
    const token = {
      access_token: tokenStr,
      token_type: "Bearer",
      expires_in: expiresIn,
      expires_at: expiresAt,
      scope,
      client_id: clientId
    };
    this.accessTokens.set(tokenStr, token);
    return token;
  }
  generateRefreshToken(clientId, scope) {
    const tokenStr = this.generateSecureToken(48);
    const expiresAt = Date.now() + this.settings.refresh_token_lifetime * 1e3;
    const token = {
      refresh_token: tokenStr,
      client_id: clientId,
      scope,
      expires_at: expiresAt
    };
    this.refreshTokens.set(tokenStr, token);
    return token;
  }
  generateSecureToken(length) {
    return crypto.randomBytes(length).toString("hex");
  }
  // ============================================================================
  // Cleanup
  // ============================================================================
  cleanupExpiredTokens() {
    const now = Date.now();
    for (const [key, code] of this.authorizationCodes) {
      if (now > code.expires_at) {
        this.authorizationCodes.delete(key);
      }
    }
    for (const [key, token] of this.accessTokens) {
      if (now > token.expires_at) {
        this.accessTokens.delete(key);
      }
    }
    for (const [key, token] of this.refreshTokens) {
      if (now > token.expires_at) {
        this.refreshTokens.delete(key);
      }
    }
  }
  // ============================================================================
  // Settings Management
  // ============================================================================
  isEnabled() {
    return this.settings.enabled;
  }
  async setEnabled(enabled) {
    this.settings.enabled = enabled;
    if (enabled) {
      if (!this.settings.clients.find((c) => c.client_id === "claude-desktop")) {
        this.settings.clients.push({
          ...CLAUDE_DESKTOP_CLIENT,
          created_at: new Date().toISOString()
        });
      }
      if (this.settings.chatgpt_gpt_id) {
        await this.registerOrUpdateChatGPTClient(this.settings.chatgpt_gpt_id);
      }
    }
    await this.saveCallback(this.settings);
  }
  /**
   * Update the ChatGPT GPT ID and register/update the corresponding client.
   */
  async setChatGPTGptId(gptId) {
    this.settings.chatgpt_gpt_id = gptId;
    if (this.settings.enabled && gptId) {
      await this.registerOrUpdateChatGPTClient(gptId);
    } else if (!gptId) {
      this.settings.clients = this.settings.clients.filter((c) => !isChatGPTClient(c.client_id));
      await this.saveCallback(this.settings);
    }
  }
  getSettings() {
    return { ...this.settings };
  }
  async updateSettings(updates) {
    this.settings = { ...this.settings, ...updates };
    await this.saveCallback(this.settings);
  }
  // Get pending authorization requests for UI
  getPendingAuthorizations() {
    const pending = [];
    const now = Date.now();
    for (const code of this.authorizationCodes.values()) {
      if (!code.user_approved && now < code.expires_at) {
        pending.push(code);
      }
    }
    return pending;
  }
};
function getAuthorizationPageHtml(clientName, scope, code, redirectUri, state) {
  const scopeDescriptions = {
    "mcp:read": "Read your notes and vault structure",
    "mcp:write": "Create, update, and delete notes",
    "mcp:admin": "Full administrative access"
  };
  const scopes = scope.split(" ").filter((s) => s);
  const scopeList = scopes.map((s) => `<li>${scopeDescriptions[s] || s}</li>`).join("\n");
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Authorize - LLM Bridges</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 20px;
    }
    .card {
      background: white;
      border-radius: 16px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      max-width: 420px;
      width: 100%;
      padding: 40px;
    }
    .logo {
      width: 64px;
      height: 64px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 24px;
      font-size: 32px;
    }
    h1 {
      color: #1a1a2e;
      font-size: 24px;
      text-align: center;
      margin: 0 0 8px;
    }
    .client-name {
      color: #667eea;
      font-weight: 600;
    }
    .subtitle {
      color: #6b7280;
      text-align: center;
      margin-bottom: 24px;
    }
    .permissions {
      background: #f3f4f6;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
    }
    .permissions h3 {
      color: #374151;
      font-size: 14px;
      margin: 0 0 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .permissions ul {
      margin: 0;
      padding-left: 20px;
      color: #4b5563;
    }
    .permissions li {
      margin-bottom: 8px;
    }
    .buttons {
      display: flex;
      gap: 12px;
    }
    button {
      flex: 1;
      padding: 14px 24px;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .approve {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
    }
    .approve:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px -10px rgba(102, 126, 234, 0.5);
    }
    .deny {
      background: white;
      color: #6b7280;
      border: 2px solid #e5e7eb;
    }
    .deny:hover {
      border-color: #d1d5db;
      background: #f9fafb;
    }
    .warning {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 12px 16px;
      border-radius: 0 8px 8px 0;
      margin-bottom: 24px;
      font-size: 14px;
      color: #92400e;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="logo">\u{1F517}</div>
    <h1>Authorize <span class="client-name">${escapeHtml(clientName)}</span></h1>
    <p class="subtitle">wants to access your Obsidian vault</p>

    <div class="warning">
      Only authorize applications you trust. This will grant access to your notes.
    </div>

    <div class="permissions">
      <h3>Permissions Requested</h3>
      <ul>
        ${scopeList}
      </ul>
    </div>

    <form method="POST" action="/oauth/authorize/decision">
      <input type="hidden" name="code" value="${escapeHtml(code)}">
      <input type="hidden" name="redirect_uri" value="${escapeHtml(redirectUri)}">
      ${state ? `<input type="hidden" name="state" value="${escapeHtml(state)}">` : ""}

      <div class="buttons">
        <button type="submit" name="decision" value="deny" class="deny">Deny</button>
        <button type="submit" name="decision" value="approve" class="approve">Authorize</button>
      </div>
    </form>
  </div>
</body>
</html>`;
}
function getErrorPageHtml(error, description) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Error - LLM Bridges</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f3f4f6;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 20px;
    }
    .card {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      max-width: 400px;
      padding: 40px;
      text-align: center;
    }
    .icon {
      font-size: 48px;
      margin-bottom: 16px;
    }
    h1 {
      color: #dc2626;
      font-size: 20px;
      margin: 0 0 12px;
    }
    p {
      color: #6b7280;
      margin: 0;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="icon">\u274C</div>
    <h1>${escapeHtml(error)}</h1>
    <p>${escapeHtml(description)}</p>
  </div>
</body>
</html>`;
}
function escapeHtml(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

// src/openapi.ts
var http = __toESM(require("http"), 1);
var TOOL_CATEGORIES = {
  "list_knowledge_bases": { tag: "Knowledge Bases", description: "Knowledge Base management operations" },
  "add_knowledge_base": { tag: "Knowledge Bases", description: "Knowledge Base management operations" },
  "update_knowledge_base": { tag: "Knowledge Bases", description: "Knowledge Base management operations" },
  "add_knowledge_base_folder_constraint": { tag: "Knowledge Bases", description: "Knowledge Base management operations" },
  "list_notes": { tag: "Notes", description: "Note operations within Knowledge Bases" },
  "create_note": { tag: "Notes", description: "Note operations within Knowledge Bases" },
  "read_note": { tag: "Notes", description: "Note operations within Knowledge Bases" },
  "update_note": { tag: "Notes", description: "Note operations within Knowledge Bases" },
  "append_note": { tag: "Notes", description: "Note operations within Knowledge Bases" },
  "move_note": { tag: "Notes", description: "Note operations within Knowledge Bases" },
  "delete_note": { tag: "Notes", description: "Note operations within Knowledge Bases" },
  "list_vault_files": { tag: "Vault", description: "Direct vault operations" },
  "search_vault": { tag: "Vault", description: "Direct vault operations" },
  "get_active_note": { tag: "Vault", description: "Direct vault operations" },
  "list_commands": { tag: "Commands", description: "Obsidian command operations" },
  "execute_command": { tag: "Commands", description: "Obsidian command operations" }
};
function generateOpenAPISpec(tools, serverUrl, version) {
  var _a, _b, _c;
  const paths = {};
  const tagsSet = /* @__PURE__ */ new Set();
  paths["/"] = {
    get: {
      operationId: "healthCheck",
      summary: "Health check",
      description: "Returns server status and version information",
      tags: ["System"],
      responses: {
        "200": {
          description: "Server is healthy",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: { type: "string", description: "Server status" },
                  version: { type: "string", description: "API version" },
                  vault: { type: "string", description: "Vault name" }
                }
              }
            }
          }
        }
      }
    }
  };
  tagsSet.add("System");
  paths["/openapi.json"] = {
    get: {
      operationId: "getOpenAPISpec",
      summary: "Get OpenAPI specification",
      description: "Returns the OpenAPI 3.0 specification document",
      tags: ["System"],
      security: [],
      // No auth required
      responses: {
        "200": {
          description: "OpenAPI specification",
          content: {
            "application/json": {
              schema: {
                type: "object",
                description: "OpenAPI 3.0 specification document"
              }
            }
          }
        }
      }
    }
  };
  for (const tool of tools) {
    const category = TOOL_CATEGORIES[tool.name] || { tag: "Other", description: "Other operations" };
    tagsSet.add(category.tag);
    const path = `/api/${tool.name.replace(/_/g, "-")}`;
    const hasRequiredParams = ((_b = (_a = tool.inputSchema.required) == null ? void 0 : _a.length) != null ? _b : 0) > 0;
    const hasAnyParams = tool.inputSchema.properties && Object.keys(tool.inputSchema.properties).length > 0;
    let method = "post";
    if (tool.name.startsWith("list_") || tool.name.startsWith("get_") || tool.name.startsWith("read_") || tool.name.startsWith("search_")) {
      method = hasRequiredParams ? "post" : "get";
    } else if (tool.name.startsWith("delete_")) {
      method = "delete";
    } else if (tool.name.startsWith("update_")) {
      method = "put";
    }
    const requestSchema = {
      type: "object",
      properties: {},
      required: tool.inputSchema.required || []
    };
    if (tool.inputSchema.properties) {
      for (const [propName, propDef] of Object.entries(tool.inputSchema.properties)) {
        if (propDef) {
          requestSchema.properties[propName] = {
            type: propDef.type,
            description: propDef.description,
            default: propDef.default,
            enum: propDef.enum
          };
        }
      }
    }
    const operation = {
      operationId: tool.name,
      summary: tool.description,
      description: generateDetailedDescription(tool),
      tags: [category.tag],
      security: [{ BearerAuth: [] }],
      responses: {
        "200": {
          description: "Successful operation",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  success: { type: "boolean" },
                  data: { type: "object", description: "Operation result" }
                }
              }
            }
          }
        },
        "400": {
          description: "Bad request - validation failed",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  error: { type: "string" },
                  details: { type: "string" }
                }
              }
            }
          }
        },
        "401": {
          description: "Unauthorized - missing or invalid authentication"
        },
        "404": {
          description: "Resource not found"
        },
        "500": {
          description: "Internal server error"
        }
      }
    };
    if ((method === "post" || method === "put") && hasAnyParams) {
      operation.requestBody = {
        required: hasRequiredParams,
        content: {
          "application/json": {
            schema: requestSchema
          }
        }
      };
    }
    if (method === "get" && hasAnyParams) {
      operation.parameters = [];
      if (tool.inputSchema.properties) {
        for (const [propName, propDef] of Object.entries(tool.inputSchema.properties)) {
          if (propDef) {
            operation.parameters.push({
              name: propName,
              in: "query",
              description: propDef.description,
              required: ((_c = tool.inputSchema.required) == null ? void 0 : _c.includes(propName)) || false,
              schema: {
                type: propDef.type,
                default: propDef.default
              }
            });
          }
        }
      }
    }
    if (method === "delete" && hasAnyParams) {
      operation.requestBody = {
        required: hasRequiredParams,
        content: {
          "application/json": {
            schema: requestSchema
          }
        }
      };
    }
    paths[path] = { [method]: operation };
  }
  const tags = Array.from(tagsSet).map((tag) => ({
    name: tag,
    description: getTagDescription(tag)
  }));
  return {
    openapi: "3.0.3",
    info: {
      title: "LLM Bridges API",
      version,
      description: `REST API for interacting with Obsidian vault through LLM Bridges.

This API exposes the same functionality as the MCP (Model Context Protocol) tools,
but through standard REST endpoints with OpenAPI documentation.

## Authentication

All endpoints (except /openapi.json) require Bearer token authentication.
Include your API key in the Authorization header:

\`\`\`
Authorization: Bearer your-api-key
\`\`\`

## Categories

- **Knowledge Bases**: Manage named collections of notes with validation rules
- **Notes**: CRUD operations on notes within Knowledge Bases
- **Vault**: Direct vault operations (file listing, search)
- **Commands**: Execute Obsidian commands`
    },
    servers: [
      {
        url: serverUrl,
        description: "OpenAPI Server"
      }
    ],
    paths,
    components: {
      securitySchemes: {
        BearerAuth: {
          type: "http",
          scheme: "bearer",
          description: "API Key or OAuth access token"
        }
      },
      schemas: {
        KnowledgeBase: {
          type: "object",
          properties: {
            name: { type: "string", description: "Unique name for the Knowledge Base" },
            description: { type: "string", description: "Human-readable description" },
            subfolder: { type: "string", description: "Root folder path in the vault" },
            organization_rules: { type: "string", description: "Organization rules (natural language)" }
          }
        },
        Note: {
          type: "object",
          properties: {
            path: { type: "string", description: "Full path to the note" },
            content: { type: "string", description: "Note content (markdown)" }
          }
        },
        ValidationResult: {
          type: "object",
          properties: {
            passed: { type: "boolean" },
            issues: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  field: { type: "string" },
                  message: { type: "string" },
                  severity: { type: "string" }
                }
              }
            }
          }
        }
      }
    },
    security: [{ BearerAuth: [] }],
    tags
  };
}
function generateDetailedDescription(tool) {
  var _a;
  let desc = tool.description;
  if (tool.inputSchema.properties && Object.keys(tool.inputSchema.properties).length > 0) {
    desc += "\n\n**Parameters:**\n";
    for (const [name, prop] of Object.entries(tool.inputSchema.properties)) {
      if (prop) {
        const required = ((_a = tool.inputSchema.required) == null ? void 0 : _a.includes(name)) ? " (required)" : " (optional)";
        desc += `- \`${name}\`${required}: ${prop.description || prop.type}
`;
      }
    }
  }
  return desc;
}
function getTagDescription(tag) {
  const descriptions = {
    "System": "System endpoints for health checks and API documentation",
    "Knowledge Bases": "Manage Knowledge Bases - named collections of notes with folder constraints and validation rules",
    "Notes": "CRUD operations on notes within Knowledge Bases, with automatic validation against folder constraints",
    "Vault": "Direct Obsidian vault operations - file listing, search, and active note access",
    "Commands": "Execute Obsidian commands programmatically",
    "Other": "Miscellaneous operations"
  };
  return descriptions[tag] || tag;
}
function getSwaggerUIHtml(openApiUrl, title) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css">
  <style>
    html { box-sizing: border-box; overflow-y: scroll; }
    *, *:before, *:after { box-sizing: inherit; }
    body { margin: 0; background: #fafafa; }
    .swagger-ui .topbar { display: none; }
    .swagger-ui .info { margin: 20px 0; }
    .swagger-ui .info .title { font-size: 2em; }
  </style>
</head>
<body>
  <div id="swagger-ui"></div>
  <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"><\/script>
  <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-standalone-preset.js"><\/script>
  <script>
    window.onload = function() {
      window.ui = SwaggerUIBundle({
        url: "${openApiUrl}",
        dom_id: '#swagger-ui',
        deepLinking: true,
        presets: [
          SwaggerUIBundle.presets.apis,
          SwaggerUIStandalonePreset
        ],
        plugins: [
          SwaggerUIBundle.plugins.DownloadUrl
        ],
        layout: "StandaloneLayout",
        persistAuthorization: true,
        tryItOutEnabled: true,
      });
    };
  <\/script>
</body>
</html>`;
}
var DEFAULT_OPENAPI_SETTINGS = {
  enabled: false,
  port: 3101
};
var OpenAPIServer = class {
  constructor(settings, bindAddress, toolExecutor, authChecker, vaultInfo) {
    this.server = null;
    this.tools = [];
    this.openApiSpec = null;
    this.settings = settings;
    this.bindAddress = bindAddress;
    this.toolExecutor = toolExecutor;
    this.authChecker = authChecker;
    this.vaultInfo = vaultInfo;
  }
  /**
   * Update tools list and regenerate OpenAPI spec
   */
  setTools(tools) {
    this.tools = tools;
    this.openApiSpec = null;
  }
  /**
   * Get the OpenAPI specification
   */
  getSpec() {
    if (!this.openApiSpec) {
      const info = this.vaultInfo();
      const serverUrl = `http://${this.bindAddress}:${this.settings.port}`;
      this.openApiSpec = generateOpenAPISpec(this.tools, serverUrl, info.version);
    }
    return this.openApiSpec;
  }
  /**
   * Start the OpenAPI server
   */
  start() {
    if (this.server) {
      this.server.close();
    }
    if (!this.settings.enabled) {
      console.log("OpenAPI server is disabled");
      return;
    }
    this.server = http.createServer(async (req, res) => {
      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
      res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
      if (req.method === "OPTIONS") {
        res.writeHead(204);
        res.end();
        return;
      }
      const url = new URL(req.url || "/", `http://${this.bindAddress}:${this.settings.port}`);
      const pathname = url.pathname;
      try {
        if (pathname === "/openapi.json" && req.method === "GET") {
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify(this.getSpec(), null, 2));
          return;
        }
        if (pathname === "/docs" && req.method === "GET") {
          res.writeHead(200, { "Content-Type": "text/html" });
          res.end(getSwaggerUIHtml("/openapi.json", "LLM Bridges API"));
          return;
        }
        if (pathname === "/" && req.method === "GET") {
          const info = this.vaultInfo();
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify({
            status: "ok",
            version: info.version,
            vault: info.name,
            openapi: true
          }));
          return;
        }
        const authResult = this.authChecker(req.headers.authorization);
        if (!authResult.authenticated) {
          res.writeHead(401, { "Content-Type": "application/json" });
          res.end(JSON.stringify({
            error: "unauthorized",
            error_description: authResult.error || "Invalid or missing authentication"
          }));
          return;
        }
        if (pathname.startsWith("/api/")) {
          const toolName = pathname.slice(5).replace(/-/g, "_");
          const tool = this.tools.find((t) => t.name === toolName);
          if (!tool) {
            res.writeHead(404, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "Tool not found", tool: toolName }));
            return;
          }
          let args = {};
          if (req.method === "GET") {
            for (const [key, value] of url.searchParams) {
              args[key] = value;
            }
          } else {
            const body = await this.readRequestBody(req);
            if (body) {
              try {
                args = JSON.parse(body);
              } catch (e) {
                res.writeHead(400, { "Content-Type": "application/json" });
                res.end(JSON.stringify({ error: "Invalid JSON body" }));
                return;
              }
            }
          }
          try {
            const result = await this.toolExecutor(toolName, args);
            res.writeHead(200, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ success: true, data: result }));
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            const statusCode = message.includes("not found") ? 404 : 400;
            res.writeHead(statusCode, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: message }));
          }
          return;
        }
        res.writeHead(404, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Not found" }));
      } catch (error) {
        console.error("OpenAPI server error:", error);
        res.writeHead(500, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Internal server error" }));
      }
    });
    this.server.listen(this.settings.port, this.bindAddress, () => {
      console.log(`OpenAPI server running at http://${this.bindAddress}:${this.settings.port}`);
      console.log(`Swagger UI: http://${this.bindAddress}:${this.settings.port}/docs`);
      console.log(`OpenAPI spec: http://${this.bindAddress}:${this.settings.port}/openapi.json`);
    });
    this.server.on("error", (err) => {
      console.error("OpenAPI server error:", err);
    });
  }
  /**
   * Stop the server
   */
  stop() {
    if (this.server) {
      this.server.close();
      this.server = null;
    }
  }
  /**
   * Restart the server
   */
  restart() {
    this.stop();
    this.start();
  }
  /**
   * Update settings
   */
  updateSettings(settings, bindAddress) {
    this.settings = settings;
    this.bindAddress = bindAddress;
    this.openApiSpec = null;
  }
  /**
   * Check if server is running
   */
  isRunning() {
    return this.server !== null && this.server.listening;
  }
  readRequestBody(req) {
    return new Promise((resolve, reject) => {
      let body = "";
      req.on("data", (chunk) => body += chunk);
      req.on("end", () => resolve(body));
      req.on("error", reject);
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  bindAddress: "127.0.0.1",
  publicUrl: "",
  // Empty means use http://{bindAddress}:{port}
  port: 3100,
  apiKey: "",
  authMethod: "apiKey",
  oauth: DEFAULT_OAUTH_SETTINGS,
  openapi: DEFAULT_OPENAPI_SETTINGS
};
var LLMBridgesPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.server = null;
    this.sessions = /* @__PURE__ */ new Map();
    this.oauthManager = null;
    this.openApiServer = null;
    this.tokenCleanupInterval = null;
  }
  async onload() {
    await this.loadSettings();
    this.kbManager = new KBManager(this.app);
    if (!this.settings.apiKey) {
      this.settings.apiKey = this.generateApiKey();
      await this.saveSettings();
    }
    this.initOAuthManager();
    this.initOpenAPIServer();
    this.tokenCleanupInterval = setInterval(() => {
      var _a;
      (_a = this.oauthManager) == null ? void 0 : _a.cleanupExpiredTokens();
    }, 5 * 60 * 1e3);
    this.addSettingTab(new LLMBridgesSettingTab(this.app, this));
    this.addRibbonIcon("bot", "LLM Bridges", () => {
      new import_obsidian2.Notice(
        this.server ? `LLM Bridges running on port ${this.settings.port}` : "LLM Bridges server not running"
      );
    });
    this.addCommand({
      id: "copy-mcp-config",
      name: "Copy Claude MCP Configuration",
      callback: () => this.copyMCPConfig()
    });
    this.addCommand({
      id: "restart-server",
      name: "Restart Server",
      callback: () => this.restartServer()
    });
    this.startServer();
  }
  initOAuthManager() {
    this.oauthManager = new OAuthManager(
      this.settings.oauth,
      async (oauthSettings) => {
        this.settings.oauth = oauthSettings;
        await this.saveSettings();
      }
    );
  }
  initOpenAPIServer() {
    const toolExecutor = async (name, args) => {
      var _a;
      const result = await this.handleMCPToolCall({ name, arguments: args });
      const text = (_a = result.content[0]) == null ? void 0 : _a.text;
      return text ? JSON.parse(text) : null;
    };
    const authChecker = (authHeader) => {
      const mockReq = { headers: { authorization: authHeader } };
      return this.checkAuthentication(mockReq);
    };
    const vaultInfo = () => ({
      name: this.app.vault.getName(),
      version: this.manifest.version
    });
    this.openApiServer = new OpenAPIServer(
      this.settings.openapi,
      this.settings.bindAddress,
      toolExecutor,
      authChecker,
      vaultInfo
    );
    this.openApiServer.setTools(this.getMCPTools());
  }
  onunload() {
    var _a;
    if (this.tokenCleanupInterval) {
      clearInterval(this.tokenCleanupInterval);
    }
    this.stopServer();
    (_a = this.openApiServer) == null ? void 0 : _a.stop();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  generateApiKey() {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for (let i = 0; i < 32; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  // ===========================================================================
  // MCP SSE Server with OAuth 2.1 Support
  // ===========================================================================
  getBaseUrl() {
    if (this.settings.publicUrl) {
      return this.settings.publicUrl.replace(/\/$/, "");
    }
    return `http://${this.settings.bindAddress}:${this.settings.port}`;
  }
  startServer() {
    if (this.server) {
      this.server.close();
    }
    this.server = http2.createServer(async (req, res) => {
      var _a, _b;
      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
      res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
      if (req.method === "OPTIONS") {
        res.writeHead(204);
        res.end();
        return;
      }
      const url = new URL(req.url || "/", this.getBaseUrl());
      if (url.pathname === "/" && req.method === "GET") {
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({
          status: "ok",
          version: this.manifest.version,
          vault: this.app.vault.getName(),
          authMethod: this.settings.authMethod
        }));
        return;
      }
      if (url.pathname === "/.well-known/oauth-authorization-server" && req.method === "GET") {
        const metadata = getAuthorizationServerMetadata(this.getBaseUrl());
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify(metadata));
        return;
      }
      if (url.pathname === "/.well-known/oauth-protected-resource" && req.method === "GET") {
        const metadata = getProtectedResourceMetadata(this.getBaseUrl());
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify(metadata));
        return;
      }
      if (url.pathname === "/oauth/authorize" && req.method === "GET") {
        if (this.settings.authMethod !== "oauth" || !this.oauthManager) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "invalid_request", error_description: "OAuth not enabled" }));
          return;
        }
        const clientId = url.searchParams.get("client_id");
        const redirectUri = url.searchParams.get("redirect_uri");
        const responseType = url.searchParams.get("response_type");
        const codeChallenge = url.searchParams.get("code_challenge");
        const codeChallengeMethod = url.searchParams.get("code_challenge_method");
        const scope = url.searchParams.get("scope") || "mcp:read mcp:write";
        const state = url.searchParams.get("state");
        if (!clientId || !redirectUri || !responseType || !codeChallenge || !codeChallengeMethod) {
          res.writeHead(400, { "Content-Type": "text/html" });
          res.end(getErrorPageHtml("Invalid Request", "Missing required OAuth parameters"));
          return;
        }
        if (responseType !== "code") {
          res.writeHead(400, { "Content-Type": "text/html" });
          res.end(getErrorPageHtml("Unsupported Response Type", "Only 'code' response type is supported"));
          return;
        }
        if (codeChallengeMethod !== "S256") {
          res.writeHead(400, { "Content-Type": "text/html" });
          res.end(getErrorPageHtml("Unsupported Code Challenge Method", "Only S256 is supported"));
          return;
        }
        const client = this.oauthManager.getClient(clientId);
        if (!client) {
          res.writeHead(400, { "Content-Type": "text/html" });
          res.end(getErrorPageHtml("Unknown Client", `Client '${clientId}' is not registered`));
          return;
        }
        if (!this.oauthManager.validateRedirectUri(clientId, redirectUri)) {
          res.writeHead(400, { "Content-Type": "text/html" });
          res.end(getErrorPageHtml("Invalid Redirect URI", "The redirect URI is not allowed for this client"));
          return;
        }
        const authCode = this.oauthManager.generateAuthorizationCode(
          clientId,
          redirectUri,
          codeChallenge,
          "S256",
          scope
        );
        res.writeHead(200, { "Content-Type": "text/html" });
        res.end(getAuthorizationPageHtml(client.client_name, scope, authCode.code, redirectUri, state || void 0));
        return;
      }
      if (url.pathname === "/oauth/authorize/decision" && req.method === "POST") {
        if (!this.oauthManager) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "invalid_request" }));
          return;
        }
        const body = await this.readRequestBody(req);
        const params = new URLSearchParams(body);
        const decision = params.get("decision");
        const code = params.get("code");
        const redirectUri = params.get("redirect_uri");
        const state = params.get("state");
        if (!code || !redirectUri) {
          res.writeHead(400, { "Content-Type": "text/html" });
          res.end(getErrorPageHtml("Invalid Request", "Missing required parameters"));
          return;
        }
        const redirectUrl = new URL(redirectUri);
        if (decision === "approve") {
          this.oauthManager.approveAuthorizationCode(code);
          redirectUrl.searchParams.set("code", code);
          if (state)
            redirectUrl.searchParams.set("state", state);
        } else {
          this.oauthManager.denyAuthorizationCode(code);
          redirectUrl.searchParams.set("error", "access_denied");
          redirectUrl.searchParams.set("error_description", "User denied the authorization request");
          if (state)
            redirectUrl.searchParams.set("state", state);
        }
        res.writeHead(302, { Location: redirectUrl.toString() });
        res.end();
        return;
      }
      if (url.pathname === "/oauth/token" && req.method === "POST") {
        if (this.settings.authMethod !== "oauth" || !this.oauthManager) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "invalid_request", error_description: "OAuth not enabled" }));
          return;
        }
        const body = await this.readRequestBody(req);
        const contentType = req.headers["content-type"] || "";
        let params;
        if (contentType.includes("application/json")) {
          const json = JSON.parse(body);
          params = new URLSearchParams(json);
        } else {
          params = new URLSearchParams(body);
        }
        const grantType = params.get("grant_type");
        const clientId = params.get("client_id");
        if (!grantType || !clientId) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "invalid_request", error_description: "Missing required parameters" }));
          return;
        }
        if (grantType === "authorization_code") {
          const code = params.get("code");
          const redirectUri = params.get("redirect_uri");
          const codeVerifier = params.get("code_verifier");
          if (!code || !redirectUri || !codeVerifier) {
            res.writeHead(400, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "invalid_request", error_description: "Missing required parameters" }));
            return;
          }
          const result = this.oauthManager.exchangeCodeForTokens(code, clientId, redirectUri, codeVerifier);
          if ("error" in result) {
            res.writeHead(400, { "Content-Type": "application/json" });
            res.end(JSON.stringify(result));
            return;
          }
          res.writeHead(200, { "Content-Type": "application/json", "Cache-Control": "no-store" });
          res.end(JSON.stringify({
            access_token: result.access_token.access_token,
            token_type: result.access_token.token_type,
            expires_in: result.access_token.expires_in,
            refresh_token: (_a = result.refresh_token) == null ? void 0 : _a.refresh_token,
            scope: result.access_token.scope
          }));
          return;
        }
        if (grantType === "refresh_token") {
          const refreshToken = params.get("refresh_token");
          if (!refreshToken) {
            res.writeHead(400, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "invalid_request", error_description: "Missing refresh_token" }));
            return;
          }
          const result = this.oauthManager.refreshAccessToken(refreshToken, clientId);
          if ("error" in result) {
            res.writeHead(400, { "Content-Type": "application/json" });
            res.end(JSON.stringify(result));
            return;
          }
          res.writeHead(200, { "Content-Type": "application/json", "Cache-Control": "no-store" });
          res.end(JSON.stringify({
            access_token: result.access_token.access_token,
            token_type: result.access_token.token_type,
            expires_in: result.access_token.expires_in,
            refresh_token: (_b = result.refresh_token) == null ? void 0 : _b.refresh_token,
            scope: result.access_token.scope
          }));
          return;
        }
        res.writeHead(400, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "unsupported_grant_type" }));
        return;
      }
      if (url.pathname === "/oauth/revoke" && req.method === "POST") {
        if (!this.oauthManager) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "invalid_request" }));
          return;
        }
        const body = await this.readRequestBody(req);
        const params = new URLSearchParams(body);
        const token = params.get("token");
        if (token) {
          this.oauthManager.revokeToken(token);
        }
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ revoked: true }));
        return;
      }
      const authResult = this.checkAuthentication(req);
      if (!authResult.authenticated) {
        const headers = { "Content-Type": "application/json" };
        if (this.settings.authMethod === "oauth") {
          headers["WWW-Authenticate"] = `Bearer resource_metadata="${this.getBaseUrl()}/.well-known/oauth-protected-resource"`;
        }
        res.writeHead(401, headers);
        res.end(JSON.stringify({
          error: "unauthorized",
          error_description: authResult.error || "Invalid or missing authentication"
        }));
        return;
      }
      if (url.pathname === "/sse" && req.method === "GET") {
        const sessionId = this.generateSessionId();
        console.log(`MCP: New SSE connection ${sessionId}`);
        res.writeHead(200, {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          "Connection": "keep-alive"
        });
        res.write(`event: endpoint
data: /messages?sessionId=${sessionId}

`);
        this.sessions.set(sessionId, res);
        req.on("close", () => {
          console.log(`MCP: SSE connection closed ${sessionId}`);
          this.sessions.delete(sessionId);
        });
        return;
      }
      if (url.pathname === "/messages" && req.method === "POST") {
        const sessionId = url.searchParams.get("sessionId");
        if (!sessionId || !this.sessions.has(sessionId)) {
          res.writeHead(404, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Session not found" }));
          return;
        }
        const body = await this.readRequestBody(req);
        try {
          const request = JSON.parse(body);
          const response = await this.handleMCPRequest(request);
          const sseRes = this.sessions.get(sessionId);
          if (sseRes) {
            sseRes.write(`event: message
data: ${JSON.stringify(response)}

`);
          }
          res.writeHead(202, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ status: "accepted" }));
        } catch (error) {
          console.error("MCP: Error handling message:", error);
          res.writeHead(500, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Internal server error" }));
        }
        return;
      }
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Not found" }));
    });
    this.server.listen(this.settings.port, this.settings.bindAddress, () => {
      console.log(`LLM Bridges MCP Server bound to ${this.settings.bindAddress}:${this.settings.port}`);
      console.log(`Public URL: ${this.getBaseUrl()}`);
      console.log(`Auth method: ${this.settings.authMethod}`);
    });
    this.server.on("error", (err) => {
      console.error("MCP Server error:", err);
      new import_obsidian2.Notice(`LLM Bridges: Server error - ${err.message}`);
    });
    if (this.openApiServer) {
      this.openApiServer.updateSettings(this.settings.openapi, this.settings.bindAddress);
      this.openApiServer.start();
    }
  }
  // ===========================================================================
  // Authentication Helpers
  // ===========================================================================
  checkAuthentication(req) {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return { authenticated: false, error: "Missing Authorization header" };
    }
    if (!authHeader.startsWith("Bearer ")) {
      return { authenticated: false, error: "Invalid authorization scheme" };
    }
    const token = authHeader.slice(7);
    if (this.settings.authMethod === "apiKey") {
      if (token === this.settings.apiKey) {
        return { authenticated: true };
      }
      return { authenticated: false, error: "Invalid API key" };
    }
    if (this.settings.authMethod === "oauth") {
      if (!this.oauthManager) {
        return { authenticated: false, error: "OAuth not configured" };
      }
      const accessToken = this.oauthManager.validateAccessToken(token);
      if (accessToken) {
        return { authenticated: true };
      }
      return { authenticated: false, error: "Invalid or expired access token" };
    }
    return { authenticated: false, error: "Unknown authentication method" };
  }
  readRequestBody(req) {
    return new Promise((resolve, reject) => {
      let body = "";
      req.on("data", (chunk) => body += chunk);
      req.on("end", () => resolve(body));
      req.on("error", reject);
    });
  }
  stopServer() {
    for (const [sessionId, res] of this.sessions) {
      res.end();
    }
    this.sessions.clear();
    if (this.server) {
      this.server.close();
      this.server = null;
    }
  }
  restartServer() {
    var _a;
    this.stopServer();
    (_a = this.openApiServer) == null ? void 0 : _a.stop();
    this.startServer();
    new import_obsidian2.Notice(`LLM Bridges restarted on port ${this.settings.port}`);
  }
  restartOpenAPIServer() {
    if (this.openApiServer) {
      this.openApiServer.updateSettings(this.settings.openapi, this.settings.bindAddress);
      this.openApiServer.restart();
      if (this.settings.openapi.enabled) {
        new import_obsidian2.Notice(`OpenAPI server restarted on port ${this.settings.openapi.port}`);
      }
    }
  }
  generateSessionId() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
  // ===========================================================================
  // MCP Request Handler
  // ===========================================================================
  async handleMCPRequest(request) {
    const { id, method, params } = request;
    try {
      let result;
      switch (method) {
        case "initialize":
          result = {
            protocolVersion: "2024-11-05",
            capabilities: { tools: {}, resources: {} },
            serverInfo: { name: "obsidian-llm-bridges", version: this.manifest.version }
          };
          break;
        case "tools/list":
          result = { tools: this.getMCPTools() };
          break;
        case "tools/call":
          result = await this.handleMCPToolCall(params);
          break;
        case "resources/list":
          result = { resources: this.getMCPResources() };
          break;
        case "resources/read":
          result = await this.handleMCPResourceRead(params);
          break;
        default:
          return {
            jsonrpc: "2.0",
            id,
            error: { code: -32601, message: `Method not found: ${method}` }
          };
      }
      return { jsonrpc: "2.0", id, result };
    } catch (error) {
      return {
        jsonrpc: "2.0",
        id,
        error: { code: -32e3, message: error instanceof Error ? error.message : String(error) }
      };
    }
  }
  getMCPTools() {
    return [
      // Knowledge Base Management
      {
        name: "list_knowledge_bases",
        description: "List all defined Knowledge Bases in the vault",
        inputSchema: { type: "object", properties: {}, required: [] }
      },
      {
        name: "add_knowledge_base",
        description: "Create a new Knowledge Base",
        inputSchema: {
          type: "object",
          properties: {
            name: { type: "string", description: "Unique name for the KB" },
            description: { type: "string", description: "Human-readable description" },
            subfolder: { type: "string", description: "Root folder path" },
            organization_rules: { type: "string", description: "Organization rules (natural language)" }
          },
          required: ["name", "description", "subfolder"]
        }
      },
      {
        name: "update_knowledge_base",
        description: "Update an existing Knowledge Base configuration",
        inputSchema: {
          type: "object",
          properties: {
            name: { type: "string", description: "Name of the KB to update" },
            description: { type: "string", description: "New description" },
            subfolder: { type: "string", description: "New root folder path" },
            organization_rules: { type: "string", description: "New organization rules" }
          },
          required: ["name"]
        }
      },
      {
        name: "add_knowledge_base_folder_constraint",
        description: "Add folder-specific validation rules to a Knowledge Base",
        inputSchema: {
          type: "object",
          properties: {
            kb_name: { type: "string", description: "Knowledge Base name" },
            subfolder: { type: "string", description: "Subfolder within KB" },
            rules: { type: "object", description: "Constraint rules (required_frontmatter_fields, etc.)" }
          },
          required: ["kb_name", "subfolder", "rules"]
        }
      },
      // Note Operations
      {
        name: "list_notes",
        description: "List all notes in a Knowledge Base",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            subfolder: { type: "string", description: "Optional subfolder within KB" }
          },
          required: ["knowledge_base_name"]
        }
      },
      {
        name: "create_note",
        description: "Create a new note with validation",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" },
            note_content: { type: "string" }
          },
          required: ["knowledge_base_name", "note_path", "note_content"]
        }
      },
      {
        name: "read_note",
        description: "Read a note's content",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" },
            offset: { type: "number" },
            limit: { type: "number" }
          },
          required: ["knowledge_base_name", "note_path"]
        }
      },
      {
        name: "update_note",
        description: "Update an existing note",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" },
            note_content: { type: "string" }
          },
          required: ["knowledge_base_name", "note_path", "note_content"]
        }
      },
      {
        name: "append_note",
        description: "Append content to an existing note",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" },
            note_content: { type: "string" }
          },
          required: ["knowledge_base_name", "note_path", "note_content"]
        }
      },
      {
        name: "move_note",
        description: "Move a note to a different location",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            origin_note_path: { type: "string" },
            new_note_path: { type: "string" }
          },
          required: ["knowledge_base_name", "origin_note_path", "new_note_path"]
        }
      },
      {
        name: "delete_note",
        description: "Delete a note",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" }
          },
          required: ["knowledge_base_name", "note_path"]
        }
      },
      // Vault Operations
      {
        name: "list_vault_files",
        description: "List files in the vault",
        inputSchema: {
          type: "object",
          properties: { path: { type: "string", description: "Folder path (optional)" } },
          required: []
        }
      },
      {
        name: "search_vault",
        description: "Search text across all notes",
        inputSchema: {
          type: "object",
          properties: {
            query: { type: "string" },
            context_length: { type: "number", default: 100 }
          },
          required: ["query"]
        }
      },
      {
        name: "get_active_note",
        description: "Get the currently open note",
        inputSchema: { type: "object", properties: {}, required: [] }
      },
      // Commands
      {
        name: "list_commands",
        description: "List available Obsidian commands",
        inputSchema: { type: "object", properties: {}, required: [] }
      },
      {
        name: "execute_command",
        description: "Execute an Obsidian command",
        inputSchema: {
          type: "object",
          properties: { command_id: { type: "string" } },
          required: ["command_id"]
        }
      }
    ];
  }
  getMCPResources() {
    return [
      {
        uri: "obsidian://vault",
        name: "Vault Info",
        description: "Current vault information",
        mimeType: "application/json"
      },
      {
        uri: "obsidian://knowledge-bases",
        name: "Knowledge Bases",
        description: "All defined Knowledge Bases",
        mimeType: "application/json"
      }
    ];
  }
  async handleMCPToolCall(params) {
    const { name, arguments: args } = params;
    let result;
    switch (name) {
      case "list_knowledge_bases": {
        const kbs = await this.kbManager.listKnowledgeBases();
        result = { knowledge_bases: kbs };
        break;
      }
      case "add_knowledge_base": {
        const kb = await this.kbManager.addKnowledgeBase(
          args.name,
          args.description,
          args.subfolder,
          args.organization_rules || ""
        );
        result = { knowledge_base: kb };
        break;
      }
      case "update_knowledge_base": {
        const kb = await this.kbManager.updateKnowledgeBase(args.name, {
          description: args.description,
          subfolder: args.subfolder,
          organization_rules: args.organization_rules
        });
        result = { knowledge_base: kb };
        break;
      }
      case "add_knowledge_base_folder_constraint": {
        const schemaValidation = validateConstraintRulesSchema(args.rules);
        if (!schemaValidation.passed) {
          throw new Error(`Invalid constraint rules: ${schemaValidation.issues.map((i) => i.message).join(", ")}`);
        }
        const constraint = await this.kbManager.addFolderConstraint(
          args.kb_name,
          args.subfolder,
          args.rules
        );
        result = { folder_constraint: constraint };
        break;
      }
      case "list_notes": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const searchPath = args.subfolder ? this.kbManager.resolveNotePath(kb, args.subfolder) : kb.subfolder;
        const notes = [];
        const folder = this.app.vault.getAbstractFileByPath(searchPath);
        if (folder instanceof import_obsidian2.TFolder) {
          const collectNotes = (f) => {
            for (const child of f.children) {
              if (child instanceof import_obsidian2.TFile && child.extension === "md") {
                notes.push({ path: child.path });
              } else if (child instanceof import_obsidian2.TFolder) {
                collectNotes(child);
              }
            }
          };
          collectNotes(folder);
        }
        result = { knowledge_base: kb, notes };
        break;
      }
      case "create_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        if (this.kbManager.noteExists(resolvedPath)) {
          throw new Error(`Note already exists at '${resolvedPath}'`);
        }
        const constraints = await this.kbManager.getFolderConstraints(kb.name);
        const constraint = findApplicableConstraint(resolvedPath, constraints);
        let validation = { passed: true, issues: [] };
        if (constraint) {
          validation = validateNote(resolvedPath, args.note_content, constraint);
          if (!validation.passed) {
            throw new Error(`Validation failed: ${validation.issues.map((i) => i.message).join(", ")}`);
          }
        }
        const folderPath = resolvedPath.substring(0, resolvedPath.lastIndexOf("/"));
        if (folderPath)
          await this.ensureFolder(folderPath);
        await this.app.vault.create(resolvedPath, args.note_content);
        result = { path: resolvedPath, validation };
        break;
      }
      case "read_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (!(file instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${resolvedPath}'`);
        const content = await this.app.vault.read(file);
        const offset = args.offset || 0;
        const limit = args.limit || DEFAULT_READ_LIMIT;
        const chunk = content.slice(offset, offset + limit);
        result = {
          path: resolvedPath,
          content: chunk,
          offset,
          has_more: offset + limit < content.length
        };
        break;
      }
      case "update_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (!(file instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${resolvedPath}'`);
        const constraints = await this.kbManager.getFolderConstraints(kb.name);
        const constraint = findApplicableConstraint(resolvedPath, constraints);
        if (constraint) {
          const validation = validateNote(resolvedPath, args.note_content, constraint);
          if (!validation.passed) {
            throw new Error(`Validation failed: ${validation.issues.map((i) => i.message).join(", ")}`);
          }
        }
        await this.app.vault.modify(file, args.note_content);
        result = { path: resolvedPath, success: true };
        break;
      }
      case "append_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (!(file instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${resolvedPath}'`);
        const existingContent = await this.app.vault.read(file);
        const newContent = existingContent.endsWith("\n") ? existingContent + args.note_content : existingContent + "\n" + args.note_content;
        const constraints = await this.kbManager.getFolderConstraints(kb.name);
        const constraint = findApplicableConstraint(resolvedPath, constraints);
        if (constraint) {
          const validation = validateNote(resolvedPath, newContent, constraint);
          if (!validation.passed) {
            throw new Error(`Validation failed: ${validation.issues.map((i) => i.message).join(", ")}`);
          }
        }
        await this.app.vault.modify(file, newContent);
        result = { path: resolvedPath, success: true };
        break;
      }
      case "move_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const originPath = this.kbManager.resolveNotePath(kb, args.origin_note_path);
        const newPath = this.kbManager.resolveNotePath(kb, args.new_note_path);
        const originFile = this.app.vault.getAbstractFileByPath(originPath);
        if (!(originFile instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${originPath}'`);
        if (this.kbManager.noteExists(newPath)) {
          throw new Error(`Note already exists at '${newPath}'`);
        }
        const content = await this.app.vault.read(originFile);
        const constraints = await this.kbManager.getFolderConstraints(kb.name);
        const constraint = findApplicableConstraint(newPath, constraints);
        if (constraint) {
          const validation = validateNote(newPath, content, constraint);
          if (!validation.passed) {
            throw new Error(`Validation failed for new location: ${validation.issues.map((i) => i.message).join(", ")}`);
          }
        }
        const newFolderPath = newPath.substring(0, newPath.lastIndexOf("/"));
        if (newFolderPath)
          await this.ensureFolder(newFolderPath);
        await this.app.vault.rename(originFile, newPath);
        result = { origin_path: originPath, new_path: newPath };
        break;
      }
      case "delete_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (!(file instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${resolvedPath}'`);
        await this.app.vault.delete(file);
        result = { deleted_path: resolvedPath };
        break;
      }
      case "list_vault_files": {
        const files = [];
        const folderPath = args.path || "";
        const listRecursive = (folder) => {
          for (const child of folder.children) {
            if (child instanceof import_obsidian2.TFile)
              files.push(child.path);
            else if (child instanceof import_obsidian2.TFolder)
              files.push(child.path + "/");
          }
        };
        if (folderPath) {
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (folder instanceof import_obsidian2.TFolder)
            listRecursive(folder);
        } else {
          listRecursive(this.app.vault.getRoot());
        }
        result = { files };
        break;
      }
      case "search_vault": {
        const search = (0, import_obsidian2.prepareSimpleSearch)(args.query);
        const contextLength = args.context_length || 100;
        const results = [];
        for (const file of this.app.vault.getMarkdownFiles()) {
          const content = await this.app.vault.cachedRead(file);
          const searchResult = search(content);
          if (searchResult) {
            results.push({
              path: file.path,
              matches: searchResult.matches.map((m) => ({
                context: content.slice(Math.max(0, m[0] - contextLength), m[1] + contextLength)
              }))
            });
          }
        }
        result = { results };
        break;
      }
      case "get_active_note": {
        const file = this.app.workspace.getActiveFile();
        if (!file)
          throw new Error("No active file");
        const content = await this.app.vault.read(file);
        result = { path: file.path, content };
        break;
      }
      case "list_commands": {
        const commands = Object.values(this.app.commands.commands).map((c) => ({
          id: c.id,
          name: c.name
        }));
        result = { commands };
        break;
      }
      case "execute_command": {
        const cmdId = args.command_id;
        if (!this.app.commands.commands[cmdId]) {
          throw new Error(`Command not found: ${cmdId}`);
        }
        this.app.commands.executeCommandById(cmdId);
        result = { success: true };
        break;
      }
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
    return { content: [{ type: "text", text: JSON.stringify(result, null, 2) }] };
  }
  async handleMCPResourceRead(params) {
    const { uri } = params;
    if (uri === "obsidian://vault") {
      return {
        contents: [{
          uri,
          mimeType: "application/json",
          text: JSON.stringify({
            name: this.app.vault.getName(),
            files: this.app.vault.getMarkdownFiles().length
          })
        }]
      };
    }
    if (uri === "obsidian://knowledge-bases") {
      const kbs = await this.kbManager.listKnowledgeBases();
      return {
        contents: [{
          uri,
          mimeType: "application/json",
          text: JSON.stringify({ knowledge_bases: kbs })
        }]
      };
    }
    throw new Error(`Unknown resource: ${uri}`);
  }
  // ===========================================================================
  // Utility Methods
  // ===========================================================================
  async ensureFolder(path) {
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing)
      return;
    const parts = path.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const folder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  copyMCPConfig() {
    let config;
    if (this.settings.authMethod === "oauth") {
      config = {
        mcpServers: {
          obsidian: {
            url: `http://127.0.0.1:${this.settings.port}/sse`
          }
        }
      };
    } else {
      config = {
        mcpServers: {
          obsidian: {
            url: `http://127.0.0.1:${this.settings.port}/sse`,
            headers: {
              Authorization: `Bearer ${this.settings.apiKey}`
            }
          }
        }
      };
    }
    navigator.clipboard.writeText(JSON.stringify(config, null, 2));
    new import_obsidian2.Notice("MCP configuration copied to clipboard!");
  }
};
var LLMBridgesSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "LLM Bridges Settings" });
    const statusEl = containerEl.createEl("div", { cls: "llm-bridges-status" });
    statusEl.createEl("p", {
      text: `Server bound to ${this.plugin.settings.bindAddress}:${this.plugin.settings.port}`
    });
    if (this.plugin.settings.publicUrl) {
      statusEl.createEl("p", {
        text: `Public URL: ${this.plugin.settings.publicUrl}`
      });
    }
    statusEl.createEl("p", {
      text: `Authentication: ${this.plugin.settings.authMethod === "oauth" ? "OAuth 2.1" : "API Key"}`,
      cls: "llm-bridges-auth-status"
    });
    containerEl.createEl("h3", { text: "Authentication" });
    new import_obsidian2.Setting(containerEl).setName("Authentication Method").setDesc("Choose how clients authenticate with the MCP server").addDropdown(
      (dropdown) => dropdown.addOption("apiKey", "API Key (Simple)").addOption("oauth", "OAuth 2.1 (Recommended for Claude)").setValue(this.plugin.settings.authMethod).onChange(async (value) => {
        this.plugin.settings.authMethod = value;
        await this.plugin.saveSettings();
        this.plugin.restartServer();
        this.display();
      })
    );
    if (this.plugin.settings.authMethod === "apiKey") {
      new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Used to authenticate MCP requests (Bearer token)").addText(
        (text) => text.setValue(this.plugin.settings.apiKey).setDisabled(true)
      ).addButton(
        (btn) => btn.setButtonText("Copy").onClick(() => {
          navigator.clipboard.writeText(this.plugin.settings.apiKey);
          new import_obsidian2.Notice("API Key copied!");
        })
      ).addButton(
        (btn) => btn.setButtonText("Regenerate").onClick(async () => {
          this.plugin.settings.apiKey = this.plugin.generateApiKey();
          await this.plugin.saveSettings();
          this.display();
          new import_obsidian2.Notice("API Key regenerated!");
        })
      );
    }
    if (this.plugin.settings.authMethod === "oauth") {
      const oauthSection = containerEl.createEl("div", { cls: "llm-bridges-oauth-section" });
      oauthSection.createEl("p", {
        text: "OAuth 2.1 is enabled. Claude Desktop will automatically authenticate using the OAuth flow.",
        cls: "setting-item-description"
      });
      const baseUrl = this.plugin.settings.publicUrl || `http://${this.plugin.settings.bindAddress}:${this.plugin.settings.port}`;
      const endpointsEl = oauthSection.createEl("div", { cls: "llm-bridges-oauth-endpoints" });
      endpointsEl.createEl("h4", { text: "OAuth Endpoints" });
      const endpointsList = endpointsEl.createEl("ul");
      endpointsList.createEl("li", {
        text: `Authorization: ${baseUrl}/oauth/authorize`
      });
      endpointsList.createEl("li", {
        text: `Token: ${baseUrl}/oauth/token`
      });
      endpointsList.createEl("li", {
        text: `Metadata: ${baseUrl}/.well-known/oauth-authorization-server`
      });
      new import_obsidian2.Setting(oauthSection).setName("Access Token Lifetime").setDesc("How long access tokens remain valid (in seconds)").addText(
        (text) => text.setValue(String(this.plugin.settings.oauth.access_token_lifetime)).setPlaceholder("3600").onChange(async (value) => {
          const lifetime = parseInt(value);
          if (!isNaN(lifetime) && lifetime > 0) {
            this.plugin.settings.oauth.access_token_lifetime = lifetime;
            await this.plugin.saveSettings();
          }
        })
      );
      new import_obsidian2.Setting(oauthSection).setName("Refresh Token Lifetime").setDesc("How long refresh tokens remain valid (in seconds)").addText(
        (text) => text.setValue(String(this.plugin.settings.oauth.refresh_token_lifetime)).setPlaceholder("604800").onChange(async (value) => {
          const lifetime = parseInt(value);
          if (!isNaN(lifetime) && lifetime > 0) {
            this.plugin.settings.oauth.refresh_token_lifetime = lifetime;
            await this.plugin.saveSettings();
          }
        })
      );
      oauthSection.createEl("h4", { text: "ChatGPT Integration" });
      oauthSection.createEl("p", {
        text: "Configure your ChatGPT Custom GPT ID to enable OAuth authentication with ChatGPT Actions.",
        cls: "setting-item-description"
      });
      new import_obsidian2.Setting(oauthSection).setName("ChatGPT GPT ID").setDesc("Your Custom GPT ID (e.g., g-abc123XYZ). Find it in the URL when editing your GPT: chatgpt.com/gpts/editor/g-xxx").addText(
        (text) => text.setValue(this.plugin.settings.oauth.chatgpt_gpt_id).setPlaceholder("g-abc123XYZ").onChange(async (value) => {
          const gptId = value.trim();
          this.plugin.settings.oauth.chatgpt_gpt_id = gptId;
          await this.plugin.saveSettings();
          if (this.plugin.oauthManager) {
            await this.plugin.oauthManager.setChatGPTGptId(gptId);
          }
          this.display();
        })
      );
      if (this.plugin.settings.oauth.chatgpt_gpt_id) {
        const gptId = this.plugin.settings.oauth.chatgpt_gpt_id;
        const chatgptHelpEl = oauthSection.createEl("div", { cls: "llm-bridges-chatgpt-help" });
        chatgptHelpEl.createEl("p", {
          text: "Configure these values in your ChatGPT Custom GPT Actions:",
          cls: "setting-item-description"
        });
        const helpList = chatgptHelpEl.createEl("ul", { cls: "setting-item-description" });
        helpList.createEl("li", { text: `Client ID: chatgpt-${gptId}` });
        helpList.createEl("li", { text: `Authorization URL: ${baseUrl}/oauth/authorize` });
        helpList.createEl("li", { text: `Token URL: ${baseUrl}/oauth/token` });
        helpList.createEl("li", { text: "Scope: mcp:read mcp:write" });
        helpList.createEl("li", { text: "Token Exchange Method: POST request" });
      }
      const clientsEl = oauthSection.createEl("div", { cls: "llm-bridges-oauth-clients" });
      clientsEl.createEl("h4", { text: "Registered Clients" });
      const clients = this.plugin.settings.oauth.clients;
      if (clients.length === 0) {
        clientsEl.createEl("p", {
          text: "No clients registered. Claude Desktop will be automatically registered on first connection.",
          cls: "setting-item-description"
        });
      } else {
        const clientsList = clientsEl.createEl("ul");
        for (const client of clients) {
          clientsList.createEl("li", {
            text: `${client.client_name} (${client.client_id})`
          });
        }
      }
    }
    containerEl.createEl("h3", { text: "Server" });
    new import_obsidian2.Setting(containerEl).setName("Bind Address").setDesc("IP address to bind server to (127.0.0.1 = local only, 0.0.0.0 = all interfaces)").addText(
      (text) => text.setValue(this.plugin.settings.bindAddress).setPlaceholder("127.0.0.1").onChange(async (value) => {
        if (value.trim()) {
          this.plugin.settings.bindAddress = value.trim();
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Port").setDesc("Port for the MCP SSE server (requires restart)").addText(
      (text) => text.setValue(String(this.plugin.settings.port)).onChange(async (value) => {
        const port = parseInt(value);
        if (!isNaN(port) && port > 0 && port < 65536) {
          this.plugin.settings.port = port;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Public URL").setDesc("Public URL for OAuth callbacks (e.g., https://mcp.example.com). Leave empty for local access.").addText(
      (text) => text.setValue(this.plugin.settings.publicUrl).setPlaceholder("https://mcp.example.com").onChange(async (value) => {
        this.plugin.settings.publicUrl = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Restart Server").setDesc("Apply settings changes").addButton(
      (btn) => btn.setButtonText("Restart").onClick(() => {
        this.plugin.restartServer();
      })
    );
    containerEl.createEl("h3", { text: "OpenAPI Server" });
    const openApiStatusEl = containerEl.createEl("div", { cls: "llm-bridges-openapi-status" });
    if (this.plugin.settings.openapi.enabled && ((_a = this.plugin.openApiServer) == null ? void 0 : _a.isRunning())) {
      openApiStatusEl.createEl("p", {
        text: `OpenAPI server running on port ${this.plugin.settings.openapi.port}`,
        cls: "llm-bridges-status-running"
      });
    } else {
      openApiStatusEl.createEl("p", {
        text: "OpenAPI server is disabled",
        cls: "llm-bridges-status-disabled"
      });
    }
    new import_obsidian2.Setting(containerEl).setName("Enable OpenAPI Server").setDesc("Expose MCP tools as REST API with Swagger UI documentation").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.openapi.enabled).onChange(async (value) => {
        this.plugin.settings.openapi.enabled = value;
        await this.plugin.saveSettings();
        this.plugin.restartOpenAPIServer();
        this.display();
      })
    );
    if (this.plugin.settings.openapi.enabled) {
      new import_obsidian2.Setting(containerEl).setName("OpenAPI Port").setDesc("Port for the OpenAPI server (separate from MCP SSE port)").addText(
        (text) => text.setValue(String(this.plugin.settings.openapi.port)).setPlaceholder("3101").onChange(async (value) => {
          const port = parseInt(value);
          if (!isNaN(port) && port > 0 && port < 65536) {
            this.plugin.settings.openapi.port = port;
            await this.plugin.saveSettings();
          }
        })
      );
      const openApiEndpointsEl = containerEl.createEl("div", { cls: "llm-bridges-openapi-endpoints" });
      openApiEndpointsEl.createEl("h4", { text: "OpenAPI Endpoints" });
      const openApiUrl = `http://${this.plugin.settings.bindAddress}:${this.plugin.settings.openapi.port}`;
      const endpointsList = openApiEndpointsEl.createEl("ul");
      endpointsList.createEl("li", {
        text: `Swagger UI: ${openApiUrl}/docs`
      });
      endpointsList.createEl("li", {
        text: `OpenAPI Spec: ${openApiUrl}/openapi.json`
      });
      new import_obsidian2.Setting(containerEl).setName("Restart OpenAPI Server").setDesc("Apply OpenAPI settings changes").addButton(
        (btn) => btn.setButtonText("Restart").onClick(() => {
          this.plugin.restartOpenAPIServer();
          this.display();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Export OpenAPI Spec to Vault").setDesc("Save openapi.json to .llm_bridges/openapi.json in your vault").addButton(
        (btn) => btn.setButtonText("Export").onClick(async () => {
          if (this.plugin.openApiServer) {
            const spec = this.plugin.openApiServer.getSpec();
            const path = ".llm_bridges/openapi.json";
            const folder = this.plugin.app.vault.getAbstractFileByPath(".llm_bridges");
            if (!folder) {
              await this.plugin.app.vault.createFolder(".llm_bridges");
            }
            const existingFile = this.plugin.app.vault.getAbstractFileByPath(path);
            if (existingFile instanceof import_obsidian2.TFile) {
              await this.plugin.app.vault.modify(existingFile, JSON.stringify(spec, null, 2));
            } else {
              await this.plugin.app.vault.create(path, JSON.stringify(spec, null, 2));
            }
            new import_obsidian2.Notice(`OpenAPI spec exported to ${path}`);
          }
        })
      );
    }
    containerEl.createEl("h3", { text: "Claude Desktop Setup" });
    const instructionsEl = containerEl.createEl("div");
    instructionsEl.createEl("p", {
      text: "Add this to your Claude Desktop configuration:"
    });
    const configEl = containerEl.createEl("pre", {
      cls: "llm-bridges-config"
    });
    const serverUrl = this.plugin.settings.publicUrl || `http://${this.plugin.settings.bindAddress}:${this.plugin.settings.port}`;
    if (this.plugin.settings.authMethod === "oauth") {
      configEl.setText(`{
  "mcpServers": {
    "obsidian": {
      "url": "${serverUrl}/sse"
    }
  }
}

Note: When using OAuth, Claude will automatically discover
the authorization endpoints and prompt you to authorize.`);
    } else {
      configEl.setText(`{
  "mcpServers": {
    "obsidian": {
      "url": "${serverUrl}/sse",
      "headers": {
        "Authorization": "Bearer ${this.plugin.settings.apiKey}"
      }
    }
  }
}`);
    }
    new import_obsidian2.Setting(containerEl).addButton(
      (btn) => btn.setButtonText("Copy MCP Configuration").setCta().onClick(() => this.plugin.copyMCPConfig())
    );
    containerEl.createEl("h4", { text: "Config File Locations" });
    const locationsEl = containerEl.createEl("ul");
    locationsEl.createEl("li", {
      text: "macOS: ~/Library/Application Support/Claude/claude_desktop_config.json"
    });
    locationsEl.createEl("li", {
      text: "Windows: %APPDATA%\\Claude\\claude_desktop_config.json"
    });
    const versionEl = containerEl.createEl("div", { cls: "llm-bridges-version" });
    versionEl.createEl("p", {
      text: `LLM Bridges v${this.plugin.manifest.version}`,
      cls: "setting-item-description"
    });
  }
};
