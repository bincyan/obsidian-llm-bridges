/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LLMBridgesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var http = __toESM(require("http"), 1);

// src/kb-manager.ts
var import_obsidian = require("obsidian");

// src/types.ts
var LLM_BRIDGES_DIR = ".llm_bridges";
var KNOWLEDGE_BASE_DIR = "knowledge_base";
var FOLDER_CONSTRAINTS_DIR = "folder_constraints";
var META_FILE = "meta.md";
var DEFAULT_READ_LIMIT = 1e4;

// src/kb-manager.ts
var KBManager = class {
  constructor(app) {
    this.app = app;
  }
  // ============================================================================
  // Path Helpers
  // ============================================================================
  /**
   * Get the base path for all KB storage
   */
  getKBBasePath() {
    return `${LLM_BRIDGES_DIR}/${KNOWLEDGE_BASE_DIR}`;
  }
  /**
   * Get the path for a specific KB's directory
   */
  getKBPath(kbName) {
    return `${this.getKBBasePath()}/${kbName}`;
  }
  /**
   * Get the path for a KB's meta.md file
   */
  getMetaPath(kbName) {
    return `${this.getKBPath(kbName)}/${META_FILE}`;
  }
  /**
   * Get the path for a KB's folder_constraints directory
   */
  getConstraintsPath(kbName) {
    return `${this.getKBPath(kbName)}/${FOLDER_CONSTRAINTS_DIR}`;
  }
  // ============================================================================
  // Knowledge Base Operations
  // ============================================================================
  /**
   * List all Knowledge Bases
   */
  async listKnowledgeBases() {
    const basePath = this.getKBBasePath();
    const baseFolder = this.app.vault.getAbstractFileByPath(basePath);
    if (!(baseFolder instanceof import_obsidian.TFolder)) {
      return [];
    }
    const kbs = [];
    for (const child of baseFolder.children) {
      if (child instanceof import_obsidian.TFolder) {
        try {
          const kb = await this.getKnowledgeBase(child.name);
          if (kb) {
            kbs.push({
              name: kb.name,
              description: kb.description,
              subfolder: kb.subfolder,
              create_time: kb.create_time,
              organization_rules_preview: kb.organization_rules.slice(0, 200) + (kb.organization_rules.length > 200 ? "..." : "")
            });
          }
        } catch (e) {
        }
      }
    }
    return kbs;
  }
  /**
   * Get a single Knowledge Base by name
   */
  async getKnowledgeBase(name) {
    const metaPath = this.getMetaPath(name);
    const file = this.app.vault.getAbstractFileByPath(metaPath);
    if (!(file instanceof import_obsidian.TFile)) {
      return null;
    }
    const content = await this.app.vault.read(file);
    return this.parseKBMeta(name, content);
  }
  /**
   * Add a new Knowledge Base
   */
  async addKnowledgeBase(name, description, subfolder, organizationRules) {
    const existing = await this.getKnowledgeBase(name);
    if (existing) {
      throw this.createError("knowledge_base_already_exists", `Knowledge base '${name}' already exists`);
    }
    const allKBs = await this.listKnowledgeBases();
    for (const kb2 of allKBs) {
      if (this.subfolderOverlaps(subfolder, kb2.subfolder)) {
        throw this.createError(
          "subfolder_overlap",
          `Subfolder '${subfolder}' overlaps with KB '${kb2.name}' subfolder '${kb2.subfolder}'`
        );
      }
    }
    const kbPath = this.getKBPath(name);
    const constraintsPath = this.getConstraintsPath(name);
    await this.ensureFolder(kbPath);
    await this.ensureFolder(constraintsPath);
    const kb = {
      name,
      create_time: new Date().toISOString(),
      description,
      subfolder: this.normalizePath(subfolder),
      organization_rules: organizationRules
    };
    const metaContent = this.serializeKBMeta(kb);
    await this.app.vault.create(this.getMetaPath(name), metaContent);
    await this.ensureFolder(kb.subfolder);
    return kb;
  }
  /**
   * Update an existing Knowledge Base
   */
  async updateKnowledgeBase(name, updates) {
    var _a, _b;
    const kb = await this.getKnowledgeBase(name);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${name}' not found`);
    }
    if (updates.subfolder && updates.subfolder !== kb.subfolder) {
      const allKBs = await this.listKnowledgeBases();
      for (const otherKb of allKBs) {
        if (otherKb.name !== name && this.subfolderOverlaps(updates.subfolder, otherKb.subfolder)) {
          throw this.createError(
            "subfolder_overlap",
            `Subfolder '${updates.subfolder}' overlaps with KB '${otherKb.name}' subfolder '${otherKb.subfolder}'`
          );
        }
      }
    }
    const updatedKB = {
      ...kb,
      description: (_a = updates.description) != null ? _a : kb.description,
      subfolder: updates.subfolder ? this.normalizePath(updates.subfolder) : kb.subfolder,
      organization_rules: (_b = updates.organization_rules) != null ? _b : kb.organization_rules
    };
    const metaPath = this.getMetaPath(name);
    const file = this.app.vault.getAbstractFileByPath(metaPath);
    if (file instanceof import_obsidian.TFile) {
      await this.app.vault.modify(file, this.serializeKBMeta(updatedKB));
    }
    if (updates.subfolder) {
      await this.ensureFolder(updatedKB.subfolder);
    }
    return updatedKB;
  }
  // ============================================================================
  // Folder Constraint Operations
  // ============================================================================
  /**
   * Get all folder constraints for a KB
   */
  async getFolderConstraints(kbName) {
    const kb = await this.getKnowledgeBase(kbName);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${kbName}' not found`);
    }
    const constraintsPath = this.getConstraintsPath(kbName);
    const folder = this.app.vault.getAbstractFileByPath(constraintsPath);
    if (!(folder instanceof import_obsidian.TFolder)) {
      return [];
    }
    const constraints = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile && child.extension === "md") {
        try {
          const content = await this.app.vault.read(child);
          const constraint = this.parseConstraint(kbName, content);
          if (constraint) {
            constraints.push(constraint);
          }
        } catch (e) {
        }
      }
    }
    return constraints;
  }
  /**
   * Add a folder constraint to a KB
   */
  async addFolderConstraint(kbName, subfolder, rules) {
    const kb = await this.getKnowledgeBase(kbName);
    if (!kb) {
      throw this.createError("knowledge_base_not_found", `Knowledge base '${kbName}' not found`);
    }
    const normalizedSubfolder = this.normalizePath(subfolder);
    if (!normalizedSubfolder.startsWith(kb.subfolder)) {
      throw this.createError(
        "invalid_note_path",
        `Subfolder '${subfolder}' is outside KB's scope '${kb.subfolder}'`
      );
    }
    const constraint = {
      kb_name: kbName,
      subfolder: normalizedSubfolder,
      rules
    };
    const constraintsPath = this.getConstraintsPath(kbName);
    await this.ensureFolder(constraintsPath);
    const filename = this.sanitizeFilename(normalizedSubfolder) + ".md";
    const filePath = `${constraintsPath}/${filename}`;
    const content = this.serializeConstraint(constraint);
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(filePath, content);
    }
    return constraint;
  }
  // ============================================================================
  // Note Path Validation
  // ============================================================================
  /**
   * Resolve and validate a note path within a KB's scope
   */
  resolveNotePath(kb, notePath) {
    let resolved = notePath;
    if (!resolved.startsWith(kb.subfolder + "/") && resolved !== kb.subfolder) {
      resolved = `${kb.subfolder}/${notePath}`;
    }
    resolved = this.normalizePath(resolved);
    if (!resolved.startsWith(kb.subfolder + "/") && resolved !== kb.subfolder) {
      throw this.createError("invalid_note_path", `Path '${notePath}' is outside KB scope '${kb.subfolder}'`);
    }
    if (resolved.includes("..")) {
      throw this.createError("invalid_note_path", "Path traversal not allowed");
    }
    return resolved;
  }
  /**
   * Check if a note exists
   */
  noteExists(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    return file instanceof import_obsidian.TFile;
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  /**
   * Parse KB meta.md content into KnowledgeBase object
   */
  parseKBMeta(name, content) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      throw new Error("Invalid meta.md format");
    }
    const frontmatter = this.parseSimpleYaml(match[1]);
    const organizationRules = match[2].trim();
    return {
      name,
      create_time: String(frontmatter.create_time || new Date().toISOString()),
      description: String(frontmatter.description || ""),
      subfolder: String(frontmatter.subfolder || ""),
      organization_rules: organizationRules
    };
  }
  /**
   * Serialize KnowledgeBase to meta.md content
   */
  serializeKBMeta(kb) {
    return `---
create_time: "${kb.create_time}"
description: "${kb.description.replace(/"/g, '\\"')}"
subfolder: "${kb.subfolder}"
---

${kb.organization_rules}`;
  }
  /**
   * Parse constraint file content
   */
  parseConstraint(kbName, content) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return null;
    }
    const frontmatter = this.parseSimpleYaml(match[1]);
    const body = match[2];
    const rulesMatch = body.match(/```ya?ml\r?\n([\s\S]*?)\r?\n```/);
    let rules = {};
    if (rulesMatch) {
      try {
        rules = this.parseRulesYaml(rulesMatch[1]);
      } catch (e) {
      }
    }
    return {
      kb_name: kbName,
      subfolder: String(frontmatter.subfolder || ""),
      rules
    };
  }
  /**
   * Serialize constraint to markdown
   */
  serializeConstraint(constraint) {
    const rulesYaml = this.serializeRulesYaml(constraint.rules);
    return `---
subfolder: "${constraint.subfolder}"
---

## Rules

\`\`\`yaml
${rulesYaml}
\`\`\`
`;
  }
  /**
   * Simple YAML parser
   */
  parseSimpleYaml(yaml) {
    const result = {};
    const lines = yaml.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      const colonIndex = trimmed.indexOf(":");
      if (colonIndex > 0) {
        const key = trimmed.slice(0, colonIndex).trim();
        let value = trimmed.slice(colonIndex + 1).trim();
        if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        result[key] = value;
      }
    }
    return result;
  }
  /**
   * Parse rules YAML - handles nested structure
   */
  parseRulesYaml(yaml) {
    const rules = {};
    const lines = yaml.split("\n");
    let currentSection = null;
    let currentField = null;
    const fields = [];
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      if (!line.startsWith(" ") && !line.startsWith("	")) {
        if (currentSection === "frontmatter" && fields.length > 0) {
          rules.frontmatter = { required_fields: fields.slice() };
        }
        const colonIdx = trimmed.indexOf(":");
        if (colonIdx > 0) {
          currentSection = trimmed.slice(0, colonIdx).trim();
          const value = trimmed.slice(colonIdx + 1).trim();
          if (currentSection === "filename" && value) {
          }
        }
        currentField = null;
        fields.length = 0;
        continue;
      }
      if (currentSection === "frontmatter") {
        if (trimmed.startsWith("- name:")) {
          if (currentField) {
            fields.push(currentField);
          }
          currentField = { name: trimmed.slice(8).trim(), type: "string" };
        } else if (currentField && trimmed.includes(":")) {
          const [key, ...valueParts] = trimmed.split(":");
          const keyName = key.trim();
          let value = valueParts.join(":").trim();
          if (value === "true")
            value = true;
          else if (value === "false")
            value = false;
          else if (value.startsWith("[") && value.endsWith("]")) {
            const arrayStr = value.slice(1, -1);
            value = arrayStr.split(",").map((v) => {
              const trimmedV = v.trim().replace(/^["']|["']$/g, "");
              if (trimmedV === "true")
                return true;
              if (trimmedV === "false")
                return false;
              const num = Number(trimmedV);
              if (!isNaN(num))
                return num;
              return trimmedV;
            });
          } else if (value.startsWith('"') || value.startsWith("'")) {
            value = value.slice(1, -1);
          }
          if (keyName === "type") {
            currentField.type = value;
          } else if (keyName === "pattern") {
            currentField.pattern = value;
          } else if (keyName === "allowed_values") {
            currentField.allowed_values = value;
          }
        }
      } else if (currentSection === "filename") {
        if (trimmed.startsWith("pattern:")) {
          const pattern = trimmed.slice(8).trim().replace(/^["']|["']$/g, "");
          rules.filename = { pattern };
        }
      } else if (currentSection === "content") {
        if (!rules.content)
          rules.content = {};
        const colonIdx = trimmed.indexOf(":");
        if (colonIdx > 0) {
          const key = trimmed.slice(0, colonIdx).trim();
          const value = trimmed.slice(colonIdx + 1).trim();
          if (key === "min_length" || key === "max_length") {
            rules.content[key] = parseInt(value) || 0;
          } else if (key === "required_sections") {
            const arr = value.slice(1, -1).split(",").map((v) => v.trim().replace(/^["']|["']$/g, ""));
            rules.content[key] = arr;
          }
        }
      }
    }
    if (currentSection === "frontmatter") {
      if (currentField) {
        fields.push(currentField);
      }
      if (fields.length > 0) {
        rules.frontmatter = { required_fields: fields };
      }
    }
    return rules;
  }
  /**
   * Serialize rules to YAML
   */
  serializeRulesYaml(rules) {
    var _a, _b;
    const lines = [];
    if ((_a = rules.frontmatter) == null ? void 0 : _a.required_fields) {
      lines.push("frontmatter:");
      lines.push("  required_fields:");
      for (const field of rules.frontmatter.required_fields) {
        lines.push(`    - name: ${field.name}`);
        lines.push(`      type: ${field.type}`);
        if (field.pattern) {
          lines.push(`      pattern: "${field.pattern}"`);
        }
        if (field.allowed_values) {
          const values = field.allowed_values.map(
            (v) => typeof v === "string" ? `"${v}"` : String(v)
          ).join(", ");
          lines.push(`      allowed_values: [${values}]`);
        }
      }
    }
    if ((_b = rules.filename) == null ? void 0 : _b.pattern) {
      lines.push("filename:");
      lines.push(`  pattern: "${rules.filename.pattern}"`);
    }
    if (rules.content) {
      lines.push("content:");
      if (rules.content.min_length !== void 0) {
        lines.push(`  min_length: ${rules.content.min_length}`);
      }
      if (rules.content.max_length !== void 0) {
        lines.push(`  max_length: ${rules.content.max_length}`);
      }
      if (rules.content.required_sections) {
        const sections = rules.content.required_sections.map((s) => `"${s}"`).join(", ");
        lines.push(`  required_sections: [${sections}]`);
      }
    }
    return lines.join("\n");
  }
  // ============================================================================
  // Utility Methods
  // ============================================================================
  /**
   * Ensure a folder exists, creating it if necessary
   */
  async ensureFolder(path) {
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing)
      return;
    const parts = path.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const folder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  /**
   * Normalize a path (remove leading/trailing slashes, etc.)
   */
  normalizePath(path) {
    return path.replace(/^\/+|\/+$/g, "").replace(/\/+/g, "/");
  }
  /**
   * Check if two subfolders overlap
   */
  subfolderOverlaps(a, b) {
    const normA = this.normalizePath(a);
    const normB = this.normalizePath(b);
    return normA.startsWith(normB + "/") || normB.startsWith(normA + "/") || normA === normB;
  }
  /**
   * Create a safe filename from a path
   */
  sanitizeFilename(path) {
    return path.replace(/\//g, "_").replace(/[^a-zA-Z0-9_-]/g, "");
  }
  /**
   * Create an API error
   */
  createError(code, message, details) {
    return { code, message, details };
  }
};

// src/validation.ts
function parseNote(content) {
  const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
  const match = content.match(frontmatterRegex);
  if (!match) {
    return {
      frontmatter: {},
      body: content,
      raw: content
    };
  }
  const frontmatterYaml = match[1];
  const body = match[2] || "";
  const frontmatter = parseSimpleYaml(frontmatterYaml);
  return {
    frontmatter,
    body,
    raw: content
  };
}
function parseSimpleYaml(yaml) {
  const result = {};
  const lines = yaml.split("\n");
  let currentKey = null;
  let currentArray = null;
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#"))
      continue;
    if (trimmed.startsWith("- ") && currentKey && currentArray) {
      const value = trimmed.slice(2).trim();
      currentArray.push(parseYamlValue(value));
      continue;
    }
    const colonIndex = trimmed.indexOf(":");
    if (colonIndex > 0) {
      const key = trimmed.slice(0, colonIndex).trim();
      const value = trimmed.slice(colonIndex + 1).trim();
      if (currentKey && currentArray) {
        result[currentKey] = currentArray;
        currentArray = null;
      }
      if (value === "" || value === "[]") {
        currentKey = key;
        currentArray = [];
      } else if (value.startsWith("[") && value.endsWith("]")) {
        const arrayContent = value.slice(1, -1);
        result[key] = arrayContent.split(",").map((v) => parseYamlValue(v.trim())).filter((v) => v !== "");
        currentKey = null;
        currentArray = null;
      } else {
        result[key] = parseYamlValue(value);
        currentKey = null;
        currentArray = null;
      }
    }
  }
  if (currentKey && currentArray) {
    result[currentKey] = currentArray;
  }
  return result;
}
function parseYamlValue(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  if (value === "null" || value === "~")
    return null;
  const num = Number(value);
  if (!isNaN(num) && value !== "")
    return num;
  return value;
}
function validateNote(notePath, content, constraint) {
  var _a, _b;
  const issues = [];
  const parsed = parseNote(content);
  const filename = notePath.split("/").pop() || "";
  if ((_a = constraint.rules.frontmatter) == null ? void 0 : _a.required_fields) {
    for (const field of constraint.rules.frontmatter.required_fields) {
      const fieldIssues = validateFrontmatterField(parsed.frontmatter, field);
      issues.push(...fieldIssues);
    }
  }
  if ((_b = constraint.rules.filename) == null ? void 0 : _b.pattern) {
    const filenameIssues = validateFilename(filename, constraint.rules.filename.pattern);
    issues.push(...filenameIssues);
  }
  if (constraint.rules.content) {
    const contentIssues = validateContent(parsed.body, constraint.rules.content);
    issues.push(...contentIssues);
  }
  return {
    passed: issues.length === 0,
    issues
  };
}
function validateFrontmatterField(frontmatter, field) {
  const issues = [];
  const value = frontmatter[field.name];
  const fieldPath = `frontmatter.${field.name}`;
  if (value === void 0 || value === null) {
    issues.push({
      field: fieldPath,
      error: "missing_required_field",
      message: `Required field '${field.name}' is missing`
    });
    return issues;
  }
  const typeValid = validateFieldType(value, field.type);
  if (!typeValid) {
    issues.push({
      field: fieldPath,
      error: "invalid_field_type",
      expected: field.type,
      actual: typeof value,
      message: `Field '${field.name}' should be type '${field.type}', got '${typeof value}'`
    });
    return issues;
  }
  if (field.pattern && typeof value === "string") {
    try {
      const regex = new RegExp(field.pattern);
      if (!regex.test(value)) {
        issues.push({
          field: fieldPath,
          error: "pattern_mismatch",
          pattern: field.pattern,
          actual: value,
          message: `Field '${field.name}' does not match pattern '${field.pattern}'`
        });
      }
    } catch (e) {
    }
  }
  if (field.allowed_values && field.allowed_values.length > 0) {
    if (!field.allowed_values.includes(value)) {
      issues.push({
        field: fieldPath,
        error: "invalid_value",
        expected: field.allowed_values,
        actual: value,
        message: `Field '${field.name}' must be one of: ${field.allowed_values.join(", ")}`
      });
    }
  }
  return issues;
}
function validateFieldType(value, expectedType) {
  switch (expectedType) {
    case "string":
      return typeof value === "string";
    case "number":
      return typeof value === "number";
    case "boolean":
      return typeof value === "boolean";
    case "date":
      if (typeof value === "string") {
        return /^\d{4}-\d{2}-\d{2}/.test(value);
      }
      return value instanceof Date;
    case "array":
      return Array.isArray(value);
    default:
      return true;
  }
}
function validateFilename(filename, pattern) {
  const issues = [];
  try {
    const regex = new RegExp(pattern);
    if (!regex.test(filename)) {
      issues.push({
        field: "filename",
        error: "pattern_mismatch",
        pattern,
        actual: filename,
        message: `Filename '${filename}' does not match pattern '${pattern}'`
      });
    }
  } catch (e) {
  }
  return issues;
}
function validateContent(body, rules) {
  const issues = [];
  if (!rules)
    return issues;
  if (rules.min_length !== void 0 && body.length < rules.min_length) {
    issues.push({
      field: "content",
      error: "content_too_short",
      expected: rules.min_length,
      actual: body.length,
      message: `Content must be at least ${rules.min_length} characters, got ${body.length}`
    });
  }
  if (rules.max_length !== void 0 && body.length > rules.max_length) {
    issues.push({
      field: "content",
      error: "content_too_long",
      expected: rules.max_length,
      actual: body.length,
      message: `Content must be at most ${rules.max_length} characters, got ${body.length}`
    });
  }
  if (rules.required_sections) {
    for (const section of rules.required_sections) {
      const headingRegex = new RegExp(`^#+\\s+${escapeRegex(section)}\\s*$`, "im");
      if (!headingRegex.test(body)) {
        issues.push({
          field: "content.sections",
          error: "missing_section",
          expected: section,
          message: `Required section '${section}' is missing`
        });
      }
    }
  }
  return issues;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function findApplicableConstraint(notePath, constraints) {
  let bestMatch = null;
  let bestMatchLength = -1;
  for (const constraint of constraints) {
    const constraintPath = constraint.subfolder.replace(/\/$/, "");
    const noteDir = notePath.substring(0, notePath.lastIndexOf("/"));
    if (notePath.startsWith(constraintPath + "/") || noteDir === constraintPath) {
      if (constraintPath.length > bestMatchLength) {
        bestMatch = constraint;
        bestMatchLength = constraintPath.length;
      }
    }
  }
  return bestMatch;
}
function validateConstraintRulesSchema(rules) {
  const issues = [];
  if (!rules || typeof rules !== "object") {
    issues.push({
      field: "rules",
      error: "invalid_field_type",
      expected: "object",
      actual: typeof rules,
      message: "Rules must be an object"
    });
    return { passed: false, issues };
  }
  const rulesObj = rules;
  if (rulesObj.frontmatter !== void 0) {
    if (typeof rulesObj.frontmatter !== "object") {
      issues.push({
        field: "rules.frontmatter",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.frontmatter
      });
    } else {
      const fm = rulesObj.frontmatter;
      if (fm.required_fields !== void 0 && !Array.isArray(fm.required_fields)) {
        issues.push({
          field: "rules.frontmatter.required_fields",
          error: "invalid_field_type",
          expected: "array",
          actual: typeof fm.required_fields
        });
      }
    }
  }
  if (rulesObj.filename !== void 0) {
    if (typeof rulesObj.filename !== "object") {
      issues.push({
        field: "rules.filename",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.filename
      });
    } else {
      const fn = rulesObj.filename;
      if (fn.pattern !== void 0 && typeof fn.pattern !== "string") {
        issues.push({
          field: "rules.filename.pattern",
          error: "invalid_field_type",
          expected: "string",
          actual: typeof fn.pattern
        });
      }
      if (typeof fn.pattern === "string") {
        try {
          new RegExp(fn.pattern);
        } catch (e) {
          issues.push({
            field: "rules.filename.pattern",
            error: "invalid_value",
            actual: fn.pattern,
            message: "Invalid regex pattern"
          });
        }
      }
    }
  }
  if (rulesObj.content !== void 0) {
    if (typeof rulesObj.content !== "object") {
      issues.push({
        field: "rules.content",
        error: "invalid_field_type",
        expected: "object",
        actual: typeof rulesObj.content
      });
    }
  }
  return {
    passed: issues.length === 0,
    issues
  };
}

// src/main.ts
var DEFAULT_SETTINGS = {
  port: 3100,
  apiKey: ""
};
var LLMBridgesPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.server = null;
    this.sessions = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    this.kbManager = new KBManager(this.app);
    if (!this.settings.apiKey) {
      this.settings.apiKey = this.generateApiKey();
      await this.saveSettings();
    }
    this.addSettingTab(new LLMBridgesSettingTab(this.app, this));
    this.addRibbonIcon("bot", "LLM Bridges", () => {
      new import_obsidian2.Notice(
        this.server ? `LLM Bridges running on port ${this.settings.port}` : "LLM Bridges server not running"
      );
    });
    this.addCommand({
      id: "copy-mcp-config",
      name: "Copy Claude MCP Configuration",
      callback: () => this.copyMCPConfig()
    });
    this.addCommand({
      id: "restart-server",
      name: "Restart Server",
      callback: () => this.restartServer()
    });
    this.startServer();
  }
  onunload() {
    this.stopServer();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  generateApiKey() {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for (let i = 0; i < 32; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  // ===========================================================================
  // MCP SSE Server
  // ===========================================================================
  startServer() {
    if (this.server) {
      this.server.close();
    }
    this.server = http.createServer(async (req, res) => {
      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
      res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
      if (req.method === "OPTIONS") {
        res.writeHead(204);
        res.end();
        return;
      }
      const url = new URL(req.url || "/", `http://127.0.0.1:${this.settings.port}`);
      if (url.pathname === "/" && req.method === "GET") {
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({
          status: "ok",
          version: this.manifest.version,
          vault: this.app.vault.getName()
        }));
        return;
      }
      if (this.settings.apiKey) {
        const authHeader = req.headers.authorization;
        if (!authHeader || authHeader !== `Bearer ${this.settings.apiKey}`) {
          res.writeHead(401, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Unauthorized", message: "Invalid or missing Bearer token" }));
          return;
        }
      }
      if (url.pathname === "/sse" && req.method === "GET") {
        const sessionId = this.generateSessionId();
        console.log(`MCP: New SSE connection ${sessionId}`);
        res.writeHead(200, {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          "Connection": "keep-alive"
        });
        res.write(`event: endpoint
data: /messages?sessionId=${sessionId}

`);
        this.sessions.set(sessionId, res);
        req.on("close", () => {
          console.log(`MCP: SSE connection closed ${sessionId}`);
          this.sessions.delete(sessionId);
        });
        return;
      }
      if (url.pathname === "/messages" && req.method === "POST") {
        const sessionId = url.searchParams.get("sessionId");
        if (!sessionId || !this.sessions.has(sessionId)) {
          res.writeHead(404, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Session not found" }));
          return;
        }
        let body = "";
        req.on("data", (chunk) => body += chunk);
        req.on("end", async () => {
          try {
            const request = JSON.parse(body);
            const response = await this.handleMCPRequest(request);
            const sseRes = this.sessions.get(sessionId);
            if (sseRes) {
              sseRes.write(`event: message
data: ${JSON.stringify(response)}

`);
            }
            res.writeHead(202, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ status: "accepted" }));
          } catch (error) {
            console.error("MCP: Error handling message:", error);
            res.writeHead(500, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "Internal server error" }));
          }
        });
        return;
      }
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Not found" }));
    });
    this.server.listen(this.settings.port, "127.0.0.1", () => {
      console.log(`LLM Bridges MCP Server listening on http://127.0.0.1:${this.settings.port}`);
    });
    this.server.on("error", (err) => {
      console.error("MCP Server error:", err);
      new import_obsidian2.Notice(`LLM Bridges: Server error - ${err.message}`);
    });
  }
  stopServer() {
    for (const [sessionId, res] of this.sessions) {
      res.end();
    }
    this.sessions.clear();
    if (this.server) {
      this.server.close();
      this.server = null;
    }
  }
  restartServer() {
    this.stopServer();
    this.startServer();
    new import_obsidian2.Notice(`LLM Bridges restarted on port ${this.settings.port}`);
  }
  generateSessionId() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
  // ===========================================================================
  // MCP Request Handler
  // ===========================================================================
  async handleMCPRequest(request) {
    const { id, method, params } = request;
    try {
      let result;
      switch (method) {
        case "initialize":
          result = {
            protocolVersion: "2024-11-05",
            capabilities: { tools: {}, resources: {} },
            serverInfo: { name: "obsidian-llm-bridges", version: this.manifest.version }
          };
          break;
        case "tools/list":
          result = { tools: this.getMCPTools() };
          break;
        case "tools/call":
          result = await this.handleMCPToolCall(params);
          break;
        case "resources/list":
          result = { resources: this.getMCPResources() };
          break;
        case "resources/read":
          result = await this.handleMCPResourceRead(params);
          break;
        default:
          return {
            jsonrpc: "2.0",
            id,
            error: { code: -32601, message: `Method not found: ${method}` }
          };
      }
      return { jsonrpc: "2.0", id, result };
    } catch (error) {
      return {
        jsonrpc: "2.0",
        id,
        error: { code: -32e3, message: error instanceof Error ? error.message : String(error) }
      };
    }
  }
  getMCPTools() {
    return [
      // Knowledge Base Management
      {
        name: "list_knowledge_bases",
        description: "List all defined Knowledge Bases in the vault",
        inputSchema: { type: "object", properties: {}, required: [] }
      },
      {
        name: "add_knowledge_base",
        description: "Create a new Knowledge Base",
        inputSchema: {
          type: "object",
          properties: {
            name: { type: "string", description: "Unique name for the KB" },
            description: { type: "string", description: "Human-readable description" },
            subfolder: { type: "string", description: "Root folder path" },
            organization_rules: { type: "string", description: "Organization rules (natural language)" }
          },
          required: ["name", "description", "subfolder"]
        }
      },
      {
        name: "update_knowledge_base",
        description: "Update an existing Knowledge Base configuration",
        inputSchema: {
          type: "object",
          properties: {
            name: { type: "string", description: "Name of the KB to update" },
            description: { type: "string", description: "New description" },
            subfolder: { type: "string", description: "New root folder path" },
            organization_rules: { type: "string", description: "New organization rules" }
          },
          required: ["name"]
        }
      },
      {
        name: "add_knowledge_base_folder_constraint",
        description: "Add folder-specific validation rules to a Knowledge Base",
        inputSchema: {
          type: "object",
          properties: {
            kb_name: { type: "string", description: "Knowledge Base name" },
            subfolder: { type: "string", description: "Subfolder within KB" },
            rules: { type: "object", description: "Constraint rules (required_frontmatter_fields, etc.)" }
          },
          required: ["kb_name", "subfolder", "rules"]
        }
      },
      // Note Operations
      {
        name: "list_notes",
        description: "List all notes in a Knowledge Base",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            subfolder: { type: "string", description: "Optional subfolder within KB" }
          },
          required: ["knowledge_base_name"]
        }
      },
      {
        name: "create_note",
        description: "Create a new note with validation",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" },
            note_content: { type: "string" }
          },
          required: ["knowledge_base_name", "note_path", "note_content"]
        }
      },
      {
        name: "read_note",
        description: "Read a note's content",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" },
            offset: { type: "number" },
            limit: { type: "number" }
          },
          required: ["knowledge_base_name", "note_path"]
        }
      },
      {
        name: "update_note",
        description: "Update an existing note",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" },
            note_content: { type: "string" }
          },
          required: ["knowledge_base_name", "note_path", "note_content"]
        }
      },
      {
        name: "append_note",
        description: "Append content to an existing note",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" },
            note_content: { type: "string" }
          },
          required: ["knowledge_base_name", "note_path", "note_content"]
        }
      },
      {
        name: "move_note",
        description: "Move a note to a different location",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            origin_note_path: { type: "string" },
            new_note_path: { type: "string" }
          },
          required: ["knowledge_base_name", "origin_note_path", "new_note_path"]
        }
      },
      {
        name: "delete_note",
        description: "Delete a note",
        inputSchema: {
          type: "object",
          properties: {
            knowledge_base_name: { type: "string" },
            note_path: { type: "string" }
          },
          required: ["knowledge_base_name", "note_path"]
        }
      },
      // Vault Operations
      {
        name: "list_vault_files",
        description: "List files in the vault",
        inputSchema: {
          type: "object",
          properties: { path: { type: "string", description: "Folder path (optional)" } },
          required: []
        }
      },
      {
        name: "search_vault",
        description: "Search text across all notes",
        inputSchema: {
          type: "object",
          properties: {
            query: { type: "string" },
            context_length: { type: "number", default: 100 }
          },
          required: ["query"]
        }
      },
      {
        name: "get_active_note",
        description: "Get the currently open note",
        inputSchema: { type: "object", properties: {}, required: [] }
      },
      // Commands
      {
        name: "list_commands",
        description: "List available Obsidian commands",
        inputSchema: { type: "object", properties: {}, required: [] }
      },
      {
        name: "execute_command",
        description: "Execute an Obsidian command",
        inputSchema: {
          type: "object",
          properties: { command_id: { type: "string" } },
          required: ["command_id"]
        }
      }
    ];
  }
  getMCPResources() {
    return [
      {
        uri: "obsidian://vault",
        name: "Vault Info",
        description: "Current vault information",
        mimeType: "application/json"
      },
      {
        uri: "obsidian://knowledge-bases",
        name: "Knowledge Bases",
        description: "All defined Knowledge Bases",
        mimeType: "application/json"
      }
    ];
  }
  async handleMCPToolCall(params) {
    const { name, arguments: args } = params;
    let result;
    switch (name) {
      case "list_knowledge_bases": {
        const kbs = await this.kbManager.listKnowledgeBases();
        result = { knowledge_bases: kbs };
        break;
      }
      case "add_knowledge_base": {
        const kb = await this.kbManager.addKnowledgeBase(
          args.name,
          args.description,
          args.subfolder,
          args.organization_rules || ""
        );
        result = { knowledge_base: kb };
        break;
      }
      case "update_knowledge_base": {
        const kb = await this.kbManager.updateKnowledgeBase(args.name, {
          description: args.description,
          subfolder: args.subfolder,
          organization_rules: args.organization_rules
        });
        result = { knowledge_base: kb };
        break;
      }
      case "add_knowledge_base_folder_constraint": {
        const schemaValidation = validateConstraintRulesSchema(args.rules);
        if (!schemaValidation.passed) {
          throw new Error(`Invalid constraint rules: ${schemaValidation.issues.map((i) => i.message).join(", ")}`);
        }
        const constraint = await this.kbManager.addFolderConstraint(
          args.kb_name,
          args.subfolder,
          args.rules
        );
        result = { folder_constraint: constraint };
        break;
      }
      case "list_notes": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const searchPath = args.subfolder ? this.kbManager.resolveNotePath(kb, args.subfolder) : kb.subfolder;
        const notes = [];
        const folder = this.app.vault.getAbstractFileByPath(searchPath);
        if (folder instanceof import_obsidian2.TFolder) {
          const collectNotes = (f) => {
            for (const child of f.children) {
              if (child instanceof import_obsidian2.TFile && child.extension === "md") {
                notes.push({ path: child.path });
              } else if (child instanceof import_obsidian2.TFolder) {
                collectNotes(child);
              }
            }
          };
          collectNotes(folder);
        }
        result = { knowledge_base: kb, notes };
        break;
      }
      case "create_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        if (this.kbManager.noteExists(resolvedPath)) {
          throw new Error(`Note already exists at '${resolvedPath}'`);
        }
        const constraints = await this.kbManager.getFolderConstraints(kb.name);
        const constraint = findApplicableConstraint(resolvedPath, constraints);
        let validation = { passed: true, issues: [] };
        if (constraint) {
          validation = validateNote(resolvedPath, args.note_content, constraint);
          if (!validation.passed) {
            throw new Error(`Validation failed: ${validation.issues.map((i) => i.message).join(", ")}`);
          }
        }
        const folderPath = resolvedPath.substring(0, resolvedPath.lastIndexOf("/"));
        if (folderPath)
          await this.ensureFolder(folderPath);
        await this.app.vault.create(resolvedPath, args.note_content);
        result = { path: resolvedPath, validation };
        break;
      }
      case "read_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (!(file instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${resolvedPath}'`);
        const content = await this.app.vault.read(file);
        const offset = args.offset || 0;
        const limit = args.limit || DEFAULT_READ_LIMIT;
        const chunk = content.slice(offset, offset + limit);
        result = {
          path: resolvedPath,
          content: chunk,
          offset,
          has_more: offset + limit < content.length
        };
        break;
      }
      case "update_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (!(file instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${resolvedPath}'`);
        const constraints = await this.kbManager.getFolderConstraints(kb.name);
        const constraint = findApplicableConstraint(resolvedPath, constraints);
        if (constraint) {
          const validation = validateNote(resolvedPath, args.note_content, constraint);
          if (!validation.passed) {
            throw new Error(`Validation failed: ${validation.issues.map((i) => i.message).join(", ")}`);
          }
        }
        await this.app.vault.modify(file, args.note_content);
        result = { path: resolvedPath, success: true };
        break;
      }
      case "append_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (!(file instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${resolvedPath}'`);
        const existingContent = await this.app.vault.read(file);
        const newContent = existingContent.endsWith("\n") ? existingContent + args.note_content : existingContent + "\n" + args.note_content;
        const constraints = await this.kbManager.getFolderConstraints(kb.name);
        const constraint = findApplicableConstraint(resolvedPath, constraints);
        if (constraint) {
          const validation = validateNote(resolvedPath, newContent, constraint);
          if (!validation.passed) {
            throw new Error(`Validation failed: ${validation.issues.map((i) => i.message).join(", ")}`);
          }
        }
        await this.app.vault.modify(file, newContent);
        result = { path: resolvedPath, success: true };
        break;
      }
      case "move_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const originPath = this.kbManager.resolveNotePath(kb, args.origin_note_path);
        const newPath = this.kbManager.resolveNotePath(kb, args.new_note_path);
        const originFile = this.app.vault.getAbstractFileByPath(originPath);
        if (!(originFile instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${originPath}'`);
        if (this.kbManager.noteExists(newPath)) {
          throw new Error(`Note already exists at '${newPath}'`);
        }
        const content = await this.app.vault.read(originFile);
        const constraints = await this.kbManager.getFolderConstraints(kb.name);
        const constraint = findApplicableConstraint(newPath, constraints);
        if (constraint) {
          const validation = validateNote(newPath, content, constraint);
          if (!validation.passed) {
            throw new Error(`Validation failed for new location: ${validation.issues.map((i) => i.message).join(", ")}`);
          }
        }
        const newFolderPath = newPath.substring(0, newPath.lastIndexOf("/"));
        if (newFolderPath)
          await this.ensureFolder(newFolderPath);
        await this.app.vault.rename(originFile, newPath);
        result = { origin_path: originPath, new_path: newPath };
        break;
      }
      case "delete_note": {
        const kb = await this.kbManager.getKnowledgeBase(args.knowledge_base_name);
        if (!kb)
          throw new Error(`Knowledge base '${args.knowledge_base_name}' not found`);
        const resolvedPath = this.kbManager.resolveNotePath(kb, args.note_path);
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (!(file instanceof import_obsidian2.TFile))
          throw new Error(`Note not found at '${resolvedPath}'`);
        await this.app.vault.delete(file);
        result = { deleted_path: resolvedPath };
        break;
      }
      case "list_vault_files": {
        const files = [];
        const folderPath = args.path || "";
        const listRecursive = (folder) => {
          for (const child of folder.children) {
            if (child instanceof import_obsidian2.TFile)
              files.push(child.path);
            else if (child instanceof import_obsidian2.TFolder)
              files.push(child.path + "/");
          }
        };
        if (folderPath) {
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (folder instanceof import_obsidian2.TFolder)
            listRecursive(folder);
        } else {
          listRecursive(this.app.vault.getRoot());
        }
        result = { files };
        break;
      }
      case "search_vault": {
        const search = (0, import_obsidian2.prepareSimpleSearch)(args.query);
        const contextLength = args.context_length || 100;
        const results = [];
        for (const file of this.app.vault.getMarkdownFiles()) {
          const content = await this.app.vault.cachedRead(file);
          const searchResult = search(content);
          if (searchResult) {
            results.push({
              path: file.path,
              matches: searchResult.matches.map((m) => ({
                context: content.slice(Math.max(0, m[0] - contextLength), m[1] + contextLength)
              }))
            });
          }
        }
        result = { results };
        break;
      }
      case "get_active_note": {
        const file = this.app.workspace.getActiveFile();
        if (!file)
          throw new Error("No active file");
        const content = await this.app.vault.read(file);
        result = { path: file.path, content };
        break;
      }
      case "list_commands": {
        const commands = Object.values(this.app.commands.commands).map((c) => ({
          id: c.id,
          name: c.name
        }));
        result = { commands };
        break;
      }
      case "execute_command": {
        const cmdId = args.command_id;
        if (!this.app.commands.commands[cmdId]) {
          throw new Error(`Command not found: ${cmdId}`);
        }
        this.app.commands.executeCommandById(cmdId);
        result = { success: true };
        break;
      }
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
    return { content: [{ type: "text", text: JSON.stringify(result, null, 2) }] };
  }
  async handleMCPResourceRead(params) {
    const { uri } = params;
    if (uri === "obsidian://vault") {
      return {
        contents: [{
          uri,
          mimeType: "application/json",
          text: JSON.stringify({
            name: this.app.vault.getName(),
            files: this.app.vault.getMarkdownFiles().length
          })
        }]
      };
    }
    if (uri === "obsidian://knowledge-bases") {
      const kbs = await this.kbManager.listKnowledgeBases();
      return {
        contents: [{
          uri,
          mimeType: "application/json",
          text: JSON.stringify({ knowledge_bases: kbs })
        }]
      };
    }
    throw new Error(`Unknown resource: ${uri}`);
  }
  // ===========================================================================
  // Utility Methods
  // ===========================================================================
  async ensureFolder(path) {
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing)
      return;
    const parts = path.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const folder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  copyMCPConfig() {
    const config = {
      mcpServers: {
        obsidian: {
          url: `http://127.0.0.1:${this.settings.port}/sse`,
          headers: {
            Authorization: `Bearer ${this.settings.apiKey}`
          }
        }
      }
    };
    navigator.clipboard.writeText(JSON.stringify(config, null, 2));
    new import_obsidian2.Notice("MCP configuration copied to clipboard!");
  }
};
var LLMBridgesSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "LLM Bridges Settings" });
    const statusEl = containerEl.createEl("div", { cls: "llm-bridges-status" });
    statusEl.createEl("p", {
      text: `MCP Server running on http://127.0.0.1:${this.plugin.settings.port}`
    });
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Used to authenticate MCP requests (Bearer token)").addText(
      (text) => text.setValue(this.plugin.settings.apiKey).setDisabled(true)
    ).addButton(
      (btn) => btn.setButtonText("Copy").onClick(() => {
        navigator.clipboard.writeText(this.plugin.settings.apiKey);
        new import_obsidian2.Notice("API Key copied!");
      })
    ).addButton(
      (btn) => btn.setButtonText("Regenerate").onClick(async () => {
        this.plugin.settings.apiKey = this.plugin.generateApiKey();
        await this.plugin.saveSettings();
        this.display();
        new import_obsidian2.Notice("API Key regenerated!");
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Port").setDesc("Port for the MCP SSE server (requires restart)").addText(
      (text) => text.setValue(String(this.plugin.settings.port)).onChange(async (value) => {
        const port = parseInt(value);
        if (!isNaN(port) && port > 0 && port < 65536) {
          this.plugin.settings.port = port;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Restart Server").setDesc("Apply port changes").addButton(
      (btn) => btn.setButtonText("Restart").onClick(() => {
        this.plugin.restartServer();
      })
    );
    containerEl.createEl("h3", { text: "Claude Desktop Setup" });
    const instructionsEl = containerEl.createEl("div");
    instructionsEl.createEl("p", {
      text: "Add this to your Claude Desktop configuration:"
    });
    const configEl = containerEl.createEl("pre", {
      cls: "llm-bridges-config"
    });
    configEl.setText(`{
  "mcpServers": {
    "obsidian": {
      "url": "http://127.0.0.1:${this.plugin.settings.port}/sse",
      "headers": {
        "Authorization": "Bearer ${this.plugin.settings.apiKey}"
      }
    }
  }
}`);
    new import_obsidian2.Setting(containerEl).addButton(
      (btn) => btn.setButtonText("Copy MCP Configuration").setCta().onClick(() => this.plugin.copyMCPConfig())
    );
    containerEl.createEl("h4", { text: "Config File Locations" });
    const locationsEl = containerEl.createEl("ul");
    locationsEl.createEl("li", {
      text: "macOS: ~/Library/Application Support/Claude/claude_desktop_config.json"
    });
    locationsEl.createEl("li", {
      text: "Windows: %APPDATA%\\Claude\\claude_desktop_config.json"
    });
  }
};
